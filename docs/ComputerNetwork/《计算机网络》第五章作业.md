# 《计算机网络》第五章作业

## 5-08

因为UDP对应用程序交下来的报文，在添加首部后就向下交付IP层，不合并也不拆分，直接保留这些报文的边界，因此UDP是面向报文的。而TCP需要先进行三次握手建立连接后才可以发送数据，在同一层上看，建立连接后，数据好像就是流式传输的，TCP无需知道上层传下来的数据是什么格式的，仅仅将其看作是一串无结构的字节流，因此TCP是面向字节流的。



## 5-17

不可行。比如，接收端收到了发送端发送的报文段$M_0$，并向发送端发送确认收到的信息，这时该确认信息丢失了，那么发送端在超过规定时间后便会超时重传，接收端不予理睬的话，发送端就会因为收不到确认信息而一直超时重传，从而使得传输失败。



## 5-18

![5-18.drawio](https://qihang-1306873228.cos.ap-chongqing.myqcloud.com/imgs/5-18.drawio.svg)

可以看到，后一次接收到的$M_0$是旧的，协议失败了。



## 5-21

（1）假定接收方之前没有收到过对发送窗口内分组的确认，那么此时窗口序号为[2, 3, 4]；

假定接收方之前只收到过对发送窗口内一个分组的确认，那么此时窗口序号为[3, 4, 5]；

假定接收方之前收到过对发送窗口内两个分组的确认，那么此时窗口序号为[4, 5, 6]；

假定接收方受到过5之前的所有分组的确认，那么此时窗口序号为[5, 6, 7]。

（2）由上题的分析，发送窗口最前在[2, 3, 4]，因此接收方可能发送了对2，3，4分组的确认，这些确认可能还滞留在网络中。这些确认是用来对2，3，4之前的分组进行的确认。



## 5-22

（1）TCP规定的序号数量为$2^{32}$个，由于一个TCP连接中传送的字节流中的每一个字节都按顺序编号，因此文件的最长长度为$2^{32}\text{B}=1\text{GB}$。

（2）一共需要发送$\lceil 2^{32}/1460 \rceil=2,941,759$个帧，帧首部的字节数总和为$66\times2,941,759=194,156,094\text{B}$，传输的总字节数为$2^{32}+194,156,094=4,489,123,390\text{B}$，因此发送所需时间为$\frac{4,489,123,390\text{B}}{10\times 10^{6} / 8 \text{B/s}}=3591.3\text{s}$，即$59.9\text{min}$。



## 5-27

由于IP数据报最大长度为$65535$字节，TCP首部最小为$20$字节，IP首部最小为$20$字节，因此数据部分最多为$65535-20-20=65495$字节。当传送数据字节长度超过TCP报文段中可编出的最大序号时，依然可以使用TCP传输，因为编号是循环的，但需要注意发送TCP数据报的时候不要让编号混乱。



## 5-32

Karn算法：在计算加权平均$\text{RTT}_S$时，只要报文段重传了，就不采用其往返时间样本。

如果不采用Karn算法，而是在收到确认时都认为是对重传报文段的确认，那么如果有一个报文在$t=r+\epsilon$到达（其中，$r$表示当前超时重传规定时间，$\epsilon$为一个极小值），这时算得的$\text{RTT}=\epsilon$。因此，如果大多数情况都像这样，那么最后就会使得重传时间减少到几乎为0。



## 5-35

广域网两节点间的传播时延为$1500(\text{km})/150000(\text{km/s})=0.01\text{s}=10\text{ms}$；每一个节点的发送时延为$960(\text{bit})/48(\text{kbit/s})=20\text{ms}$，因此单程端到端时延为$20\times 5+ 10\times 3+250\times2=630\text{ms}$。



## 5-36

因为有一个广域网传播时延为$150\text{ms}$，因此端到端时延为$20\times 4+ 10\times 3 + 150+250\times2=760\text{ms}$。



## 5-39

（1）

![image-20221108221854831](https://qihang-1306873228.cos.ap-chongqing.myqcloud.com/imgs/image-20221108221854831.png)

（2）慢开始：[1, 6], [24, 26]。

（3）拥塞避免：[6, 16], [17, 22]。

（4）从16到17得过程中cwnd减半，因此是采用了快恢复算法，说明是收到了三个重复确认。从22到23直接减为1，因此是采用了慢开始算法，说明是通过超时检测到丢失报文段。

（5）第1轮次是32，第18轮次设置为21（拥塞窗口42的一半），第24轮次重新设置为13（拥塞窗口26的一般）。

（6）第1轮发送前1个报文段，第2轮发送完前3个报文段，第3轮发送完前7个报文段，第4轮发送完前15个报文段，第5段发送完前31个报文段，第6轮发送完前63个报文段，第7轮发送完前96个报文段，因此第70报文段是在**第7轮**发送出的。

（7）此时执行快恢复算法，cwnd设置为$8/2=4$。ssthresh设置为拥塞窗口的一半，即$8/2=4$。



## 5-41

![5-41-3.drawio](https://qihang-1306873228.cos.ap-chongqing.myqcloud.com/imgs/5-41-3.drawio.svg)



## 5-46

如果仅进行一次握手，由于接收端无需返回确认信息，那么如果发送端发送的报文丢失，发送端也不知道。因此不能仅进行一次握手。

如果进行两次握手，由于发送端无需返回对接收端发送来报文的确认信息，那么如果接收端发给发送端的确认信息在传输中丢失了，此时接收端仍认为已经建立连接，并等待发送端向其发送数据，而发送端由于没收到确认信息，因此也不会发送数据，此时接收端就会一直等待。

如果进行大于三次握手，那么相对于三次握手来说效率就有所下降了，因此连接建立需要进行三报文握手。

或者考虑另一种情况，如果在网络中滞留着上一次TCP连接中的报文，那么如果这个报文突然传到接收端了，那么接收端就会认为发送端请求建立连接，于是就分配资源等待接收端发送数据，而发送端并没有想建立连接，这就会导致接收端资源浪费。而由于三次握手中如果发送端接收到了接收端的确认信息发现不对，那就会发送复位报文段，告诉接收端拒绝了连接，这样就不会导致上述的问题了。



## 5-61

下方**可用窗口的位置为发送窗口内白色的区域**。

（1）A发送数据不会对发送窗口造成影响。

<img src="https://qihang-1306873228.cos.ap-chongqing.myqcloud.com/imgs/image-20221108183031540.png" alt="image-20221108183031540" style="zoom:50%;" />

（2）A把数据发完。

<img src="https://qihang-1306873228.cos.ap-chongqing.myqcloud.com/imgs/image-20221108183256345.png" alt="image-20221108183256345" style="zoom:50%;" />

（3）收到确认1000号，因此窗口移到1001以后。

<img src="https://qihang-1306873228.cos.ap-chongqing.myqcloud.com/imgs/image-20221108183536765.png" alt="image-20221108183536765" style="zoom:50%;" />

（4）再发送850B。

<img src="https://qihang-1306873228.cos.ap-chongqing.myqcloud.com/imgs/image-20221108183925283.png" alt="image-20221108183925283" style="zoom:50%;" />

（5）发送方收到的ack已经不在窗口了，所以不变化.

<img src="https://qihang-1306873228.cos.ap-chongqing.myqcloud.com/imgs/image-20221108183925283.png" style="zoom:50%;" />

（6）收到确认2047号，因此窗口移到2048以后。

<img src="https://qihang-1306873228.cos.ap-chongqing.myqcloud.com/imgs/image-20221108184431658.png" alt="image-20221108184431658" style="zoom:50%;" />

（7）A把数据发完。由于数据总大小为3kB，因此最多就到3072以前。

<img src="https://qihang-1306873228.cos.ap-chongqing.myqcloud.com/imgs/image-20221108184834097.png" alt="image-20221108184834097" style="zoom:50%;" />

（8）全部都接收到了，窗口移到3072以后。

<img src="https://qihang-1306873228.cos.ap-chongqing.myqcloud.com/imgs/image-20221108184941089.png" alt="image-20221108184941089" style="zoom:50%;" />



## 5-68

假设A是发送端（主动打开连接的一方），B是接收端（被动打开连接的一方）。那么在TCP的连接建立过程中，如果第三个报文丢失，那么A就会建立TCP连接，B还是在SYN-RCVD阶段。

- 如果此时A没有紧接着发送数据，那么B经过一段时间后就会回到CLOSED状态，需要重新建立连接。
- 如果此时A紧接着发送数据，那么此时A发送的数据报中自己的序号没有改变，与丢失的确认帧序号相同，且确认位ACK=1，确认号也是B选择的初始序号加1。当B接收到此报文段后就进入ESTABLISHED状态，继续接收A发送的数据。此时，第三个报文丢失不会对TCP建立造成影响。

综上，第三个报文段不确认对于在A建立连接后长时间不传输数据会有影响，而对于A建立连接后立即开始传输数据不会有什么影响。



