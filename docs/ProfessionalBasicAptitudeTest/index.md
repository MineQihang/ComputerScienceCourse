<center><h1>专业基本能力测试（2023春）</h1></center>

# 判断题（5题，每题3分，共15分）

## 1-1 

**题目：**c语言的数组下标从0开始。

**答案：**T

## 1-2 

**题目：**判断两个浮点数是否相同的运算虽然符合C语言规则，但是应该尽量避免。

**答案：**T

## 1-3 

**题目：**C语言程序不区分大小写。

**答案：**F

## 1-4 

**题目：**函数的参数个数和类型都相同，只是返回值不同，这不是重载函数。

**答案：**T

## 1-5 

**题目：**重载运算符可以保持原运算符的优先级和结合性不变。

**答案：**T

## 1-6 

**题目：**基类与派生类对象之间具有赋值兼容的关系，可以进行类型间的转换，派生类对象可以直接转换为基类对象，同样基类对象也可以直接转换为派生类对象 。

**答案：**F

> **说明：**基类与派生类之间的类型转换并不是双向的，**派生类对象可以转换为基类对象，但是反过来基类对象并不能直接转换为派生类对象**。
>
> 将基类对象直接转换为派生类对象是不安全的，因为基类对象只包含了基类的成员变量和方法，而派生类还有自己的成员变量和方法，如果直接转换会导致派生类对象中的成员变量和方法没有被初始化或者被错误地初始化，这可能会导致程序出现未定义的行为。
>
> 如果需要将基类对象转换为派生类对象，可以使用强制类型转换（例如static_cast或dynamic_cast），但需要保证转换是合法的，否则会导致运行时错误。
>
> 以下是一个例子，说明基类对象不能直接转换为派生类对象：
>
> ```c++
> class Base {
> public:
>     int x;
>     void print() {
>         std::cout << "Base: x=" << x << std::endl;
>     }
> };
> 
> class Derived : public Base {
> public:
>     int y;
>     void print() {
>         std::cout << "Derived: x=" << x << ", y=" << y << std::endl;
>     }
> };
> 
> int main() {
>     Base b;
>     b.x = 1;
> 
>     Derived d = static_cast<Derived>(b);  // 错误的转换
>     d.print();  // 未定义的行为
> 
>     return 0;
> }
> ```
>
> 在上述代码中，将基类对象b直接转换为派生类对象d，这是不安全的，因为Derived对象中包含了Base对象的成员变量和方法，但是Base对象中并没有Derived对象的成员变量和方法，这会导致Derived对象中的y成员变量没有被初始化或者被错误地初始化，从而导致程序出现未定义的行为。

## 1-7 

**题目：**多重继承派生类的构造函数，需要调用所有的基类构造函数来完成各基类数据成员的初始化。

**答案：**T

> **说明：**在多重继承中，一个派生类同时继承了多个基类，因此在构造派生类对象时需要调用所有基类的构造函数来完成各个基类数据成员的初始化。
>
> 具体地说，在多重继承中，每个基类都有自己的构造函数，当创建一个派生类对象时，需要显式地调用每个基类的构造函数来初始化该基类的数据成员。如果派生类没有显式地调用基类的构造函数，则编译器会自动生成一个默认的基类构造函数。但是，这个默认构造函数只能调用每个基类的默认构造函数，并不能传递参数，因此无法完成基类数据成员的初始化。
>
> 下面是一个多重继承的例子，展示了派生类的构造函数如何调用多个基类的构造函数来完成各基类数据成员的初始化：
>
> ```c++
> class Base1 {
> public:
>     Base1(int x) : x_(x) {}
>     int x_;
> };
> 
> class Base2 {
> public:
>     Base2(int y) : y_(y) {}
>     int y_;
> };
> 
> class Derived : public Base1, public Base2 {
> public:
>     Derived(int x, int y, int z) : Base1(x), Base2(y), z_(z) {}
>     int z_;
> };
> 
> int main() {
>     Derived d(1, 2, 3);
>     std::cout << "x=" << d.x_ << ", y=" << d.y_ << ", z=" << d.z_ << std::endl;
>     return 0;
> }
> ```
>
> 在上述代码中，Derived类同时继承了Base1和Base2两个基类，它的构造函数需要调用Base1和Base2的构造函数来完成它们的数据成员`x_`和`y_`的初始化。在构造函数中，使用了成员初始化列表来分别调用Base1和Base2的构造函数，并传递相应的参数。最终，派生类对象d的数据成员`x_`、`y_`和`z_`被分别初始化为1、2和3。

## 1-8 

**题目：**局部变量可以与成员变量重名。

**答案：**T

> **说明：**在C++中，成员变量和局部变量可以重名，因为它们处于不同的作用域。成员变量属于类作用域，而局部变量属于函数作用域。
>
> 当在成员函数中引用一个名称时，编译器首先在当前作用域中查找该名称，如果找到了，则使用该名称引用该变量；如果没有找到，则向上查找该名称，直到找到该名称的定义为止。这种名称查找的过程称为“名字查找”或“名字解析”。
>
> 在成员函数中，如果局部变量和成员变量重名，则局部变量会隐藏成员变量，即在成员函数中使用该名称时，编译器会优先使用局部变量。如果想要访问成员变量，需要使用“作用域解析运算符”::来指定成员变量所在的作用域。

## 1-9 

**题目：**实例变量是属于对象的。一个类的多个对象对实例变量可以设置不同的值。

**答案：**T

## 1-10 

**题目：**所有NP问题都是可判定的。

**答案：**T

> **说明：**NP类问题(Nondeterministic polynominal)：能在多项式时间内验证出一个正确解的问题，也就是说这个问题不一定在多项式时间内可解，但可以在多项式时间内验证；
>
> 在计算理论中，可判定的（decidable）指的是能够构造一个算法，能够对于所有的输入，总是在有限的时间内停机并给出一个确定的答案。
>
> 如果这句话的意思是“所有NP问题都可以判定其解的正确性”，那么它是正确的，因为NP问题本质上是可以在多项式时间内验证解的正确性的。因此，从这个角度来说，这句话是正确的。
>
> 需要注意的是，虽然NP问题可以在多项式时间内验证解的正确性，但是并不是所有NP问题都可以在多项式时间内求解。如果把“可判定”理解为“可解决”，那么这句话就不正确了。因此，具体要看这句话的表述和背景，才能确定它是否正确。

## 1-11 

**题目：**所有NP完全问题都是NP问题。

**答案：**T

> 与NP问题相关的概念有：
>
> 1. P问题：P问题是指可以在多项式时间内求解的问题，也就是说，存在一个多项式时间复杂度的算法可以解决这些问题。P问题是计算复杂性理论中最基本的问题类之一。
> 2. NP问题：NP问题是指可以在多项式时间内验证解的正确性，但不能在多项式时间内求解的问题。NP问题是比P问题更加困难的问题类。
> 3. NP完全问题：**NP完全问题是指那些既是NP问题，又是NP问题的“最难”问题**，也就是说，所有的NP问题都可以在多项式时间内约化为一个NP完全问题。如果能够找到一个多项式时间内求解NP完全问题的算法，那么就可以将该算法应用于所有的NP问题，从而在多项式时间内求解这些NP问题。
> 4. NP难问题：NP难问题是指那些比NP问题更加困难的问题，它们不一定可以在多项式时间内验证解的正确性，更不可能在多项式时间内求解。NP难问题是计算复杂性理论中最难的问题类之一。
>
> 这些问题的区别在于它们所需的计算资源和时间复杂度的不同。P问题可以在多项式时间内求解，NP问题可以在多项式时间内验证解的正确性，但不能在多项式时间内求解，而NP完全问题是NP问题的“最难”问题，它们可以在多项式时间内约化为其他NP问题。NP难问题则是比NP问题更加困难，可能需要指数级时间复杂度才能求解。

## 1-12 

**题目：**线性表L如果需要频繁地进行不同下标元素的插入、删除操作，此时选择顺序存储结构更好。

**答案：**F

> **说明：**使用顺序存储会导致插入删除的时候大量移动元素，时间复杂度是$O(n)$的。这时应采用链式存储结构，其插入删除的时间复杂度为$O(1)$。

## 1-13 

**题目：**栈的特性：栈是后进先出的线性表。

**答案：**T

## 1-14 

**题目：**队列的特性：队列是后进先出的线性表。

**答案：**F



# 单选题（5题，每题3分，共15分）

## 2-1 

**题目：**按照标识符的要求，（ ）不能组成标识符。
A. 连接符
B. 下划线
C. 大小写字母
D. 数字字符

**答案：**A

> **说明：**连接符`-`会被识别成减号。

## 2-2 

**题目：**对于 C/C++语言的函数，下列叙述中正确的是（ ）。
A. 函数的定义不能嵌套，但函数调用可以嵌套
B. 函数的定义可以嵌套，但函数调用不能嵌套
C. 函数的定义和调用都不能嵌套
D. 函数的定义和调用都可以嵌套

**答案：**A

> 对于以下代码，会出现编译错误。
> ```c++
> #include <iostream>
> 
> void a (){
>     void b () {
>         std::cout << "Hello, World!" << std::endl;
>     }
>     b();
> }
> 
> int main() {
>     a();
>     return 0;
> }
> ```
>
> 而对于以下代码，编译正确。
>
> ```c++
> #include <iostream>
> 
> void b () {
>     std::cout << "Hello, World!" << std::endl;
> }
> 
> void a (){
>     b();
> }
> 
> int main() {
>     a();
>     return 0;
> }
> ```
>
> 这说明：对于 C/C++语言的函数，函数的定义不能嵌套，但函数调用可以嵌套。
>
> 需要注意的是，可以使用匿名函数通过对象的形式实现函数中函数的定义。
>
> ```c++
> void a (){
>     auto b = []() {
>         std::cout << "Hello, World!" << std::endl;
>     };
>     b();
> }
> ```
>
> 但本题忽略这种情况。

## 2-3 

**题目：**下列叙述中正确的是（）。   

A. break语句只能用于switch语句
B. 在switch语句中必须使用default
C. break语句必须与switch语句中的case配对使用
D. 在switch语句中，不一定使用break语句

**答案：**D

## 2-4 

**题目：**执行以下循环语句时，下列说法正确的是（）。

```c++
x = -1; 
do { 
      x = x * x; 
} while (x == 0); 
```

A. 循环体将执行一次
B. 循环体将执行两次
C. 循环体将执行无限次
D. 系统将提示有语法错误

**答案：**A

## 2-5 

**题目：**关于结构化程序设计

结构程序设计的三种结构是 ▁▁▁▁▁。
A. 顺序结构、选择结构、转移结构
B. 分支结构、等价结构、循环结构
C. 多分支结构、赋值结构、等价结构
D. 顺序结构、选择结构、循环结构

**答案：**D

## 2-6 

**题目：**以下叙述错误的是（ ）。   

A. 指针可以进行加、减等算术运算;
B. 指针中存放的是地址值
C. 指针是一个变量
D. 指针变量不占用存储空间

**答案：**D

## 2-7 

**题目：**关于递归函数以下叙述错误的是（ ）。  

A. 递归函数是自己调用自己。
B. 递归函数的运行速度很快。
C. 递归函数占用较多的存储空间。
D. 递归函数的运行速度一般比较慢。

**答案：**B

## 2-8 

**题目：**下列程序段中，非死循环的是（  ）。
A. 

```C++
int i=100;
 while(1)
 { i=i%100+1;
   if(i>=100)
	   break;	
}
```

B. 

```C++
int k=0;
 do{
     ++k;
 }while(k>=0);
```

C. 

```C++
int s=10;
 while(s) 
   s++;
```

D. 

```C++
for(   ;   ;    )
```

**答案：**A

## 2-9 

**题目：**关于面向对象程序设计

面向对象程序设计主要考虑的是提高软件的 ▁▁▁▁▁。
A. 可靠性
B. 可移植性
C. 可修改性
D. 可重用性

**答案：**D

## 2-10 

**题目：**关于设计程序的原则

在设计程序时，应采纳的原则之一是 ▁▁▁▁▁。
A. 程序结构应有助于读者理解
B. 不限制 goto 语句的使用
C. 减少或取消注释行
D. 程序越短越好

**答案：**A

## 2-11 

**题目：**一个C/C++程序总是从(     )函数开始执行。 

A. main
B. 处于最前的
C. 处于最后的
D. 随机选一个

**答案：**A

## 2-12 

**题目：**C/C++语言可用的注释符有(     )。 

A. ``` //```
B. ``` /*```……```*/```
C. ```//```、```/*```……```*/```
D. ```--```

**答案：**C

## 2-13 

**题目：**二叉树的形态

由 3 个结点可以构造出 ▁▁▁▁▁ 种不同形态的二叉树。
A. 2
B. 3
C. 4
D. 5

**答案：**D

> **说明：**
>
> ```
>     1     1     1     1          1
>    /     /       \     \        / \
>   2     2         2     2      2   3
>  /       \       /       \
> 3         3     3         3
> ```

## 2-14 

**题目：**二叉树的高度

若根节点为高度1，一棵具有 1025 个结点的二叉树的高度为 ▁▁▁▁▁ 。

A. 10
B. 11
C. 11～1025 之间
D. 10～1024 之间

**答案：**C

> **说明：**长链长度为1025，选C。下面证明最低的高度
>
> 具有1个节点的完全二叉树：高度为1；
>
> 具有3个节点的完全二叉树：高度为2；
>
> 具有7个节点的完全二叉树：高度为3；
>
> ...
>
> 具有n个节点的完全二叉树：高度为$\lceil \log(n + 1) \rceil$。
>
> 当$n=1025$时，高度为11。

## 2-15 

**题目：**图的遍历(广度优先)

对下图进行广度优先遍历，得到的序列不可能为 ▁▁▁▁▁ 。

![题图.jpg](https://images.ptausercontent.com/629a7d5e-6eb7-4622-a10b-c45f21bba093.jpg)

A. BCFADE
B. DCEFBA
C. AFEBCD
D. CDFBAE

**答案：**D

> **说明：**对于D选项来说，首先将C加入队列，然后从队列中取出队列首部的C，依次加入其相邻边D、F、B，下一次取出的为D，加入其相邻边E，而此时选项给出了A，这是错误的！

## 2-16 

**题目：**拓扑排序

▁▁▁▁▁ 是下面 AOV 网的一个拓扑序列。

![题图.jpg](https://images.ptausercontent.com/06ebf95f-6dd4-45ab-8310-861443fb62fd.jpg)

A. BDACFEG
B. ACBDFEG
C. ABDCFEG
D. CDEABFG

**答案：**B

> **说明：**
>
> A选项：首先取出B是错误的，因为此时B的入度还不为0
>
> D选项：首先取出C是错误的，因为此时B的入度还不为0
>
> C选项：取出AB后D的入度还不为0，这个时候取出是错误的

## 2-17 

**题目：**用S表示入栈操作，X表示出栈操作，若元素入栈的顺序为1234，为了得到1342出栈顺序，相应的S和X的操作串为( )。   


A. SXSSSXXX
B. SXSXSXSX
C. SSSSXXXX
D. SXSSXSXX

**答案：**D

## 2-18 

**题目：**假设某个带头结点的单链表的头指针为head，则判定该表为空表的条件是（  ）


A. head==NULL
B. head->next==NULL
C. head!=NULL
D. head->next==head

**答案：**B

> **说明：**单链表头指针的next指针指向第一个元素，如果没有元素，那么next指针为NULL。

## 2-19 

**题目：**已知普通表达式```c/(e-f)*(a+b)```，对应的后缀表达式是（  ）

A. ```cef/-ab*+```
B. ```ef-c/ab+* ```
C. ```cef-/ab+*```
D. ```c/e-f*a+b```

**答案：**C

## 2-20 

**题目：**给定有限符号集 S , in 和 out 均为 S 中所有元素的任意排列。 对于初始为空的栈 ST, 下列叙述中，正确的是：

A. 若 in 是 ST 的入栈序列， 则不能判断 out 是否为其可能的出栈序列
B. 若 out 是 ST 的出栈序列，则不能判断 in 是否为其可能的入栈序列
C. 若 in 是 ST 的入栈序列，out 是对应 in 的出栈序列， 则 in 与 out 一定不同
D. 若 in 是 ST 的入栈序列，out 是对应 in 的出栈序列， 则 in 与 out 可能互为倒序

**答案：**D

## 2-21 

**题目：**对数据进行排序时，若采用直接插入排序而不采用快速排序，则可能的原因是

I. 大部分元素已有序

II. 待排序元素数量很少

III. 要求空间复杂度为O(1)

IV. 要求排序算法是稳定的

A. 仅 I、II
B. 仅 III、IV
C. 仅 I、II、IV
D. I、II、III、IV

**答案：**D

## 2-22 

**题目：**C++面向对象程序设计中，有一个类A和类B，他们之间的继承关系不可以是：

A. A公有继承B
B. A私有继承B
C. A保护继承B
D. A抽象继承B

**答案：**D

## 2-23 

**题目：**C++的类不可以包含的成员是：
A. 公有数据成员
B. 保护型成员函数
C. 私有成员函数
D. 纯虚数据成员

**答案：**D

> **说明：**在C++中，纯虚函数可以定义为virtual function = 0; 但是，纯虚数据成员是不允许的。因为纯虚函数只是在类中声明一个虚函数，并不需要为它提供实现，而纯虚数据成员无法在类中初始化，也无法为其提供默认值，因此不允许在类中声明。

## 2-24 

**题目：**下面关于C++类的描述哪些是错误的：
A. 任何一个类都有构造函数
B. 可以没有构造函数
C. 可以有拷贝构造函数
D. 可以包含多个构造函数

**答案：**B

## 2-25 

**题目：**关于C++类的构造函数哪些是错误的：
A. 构造函数可以有返回值
B. 构造函数与类名相同
C. 默认构造函数没有参数
D. 构造函数一定是公有函数

**答案：**A

## 2-26 

**题目：**关于类A的叙述，下面哪些陈述是错误的：
A. 类A的构造函数可以访问该类的所有数据成员
B. 类A的构造函数不能访问类A的私有数据成员
C. 构造函数用来完成对象的初始化
D. 可以重载构造函数

**答案：**B

## 2-27 

**题目：**在C++面向对象程序设计中，关于复制构造函数的叙述哪些是错误的：
A. 复制构造函数与普通构造函数的名字不同
B. 可以同时出现复制构造函数和默认构造函数
C. 复制构造函数的形参类型是引用类型
D. 复制构造函数与默认构造函数是重载关系

**答案：**A

> **说明：**在C++中，主要有以下几种构造函数：
>
> 1. 默认构造函数：不带任何参数，用于创建对象时初始化成员变量的默认值。
> 2. 带参数的构造函数：带有一个或多个参数，用于创建对象时根据传入参数来初始化成员变量。
> 3. 复制构造函数：使用已有对象来初始化新对象的构造函数。通常参数类型是对该类的引用。
> 4. 移动构造函数：将一个临时对象中的资源（如内存）转移到另一个对象中的构造函数。通常参数类型是对该类的右值引用。
> 5. 转换构造函数：将一个对象从一种类型转换为另一种类型的构造函数，通常只带有一个参数。
> 6. 隐式构造函数：当派生类中缺少构造函数时，编译器自动提供的默认构造函数。
> 7. 析构函数：对象销毁时自动调用的函数，用于释放对象所占用的资源。其名称与类名相同，前面加一个波浪号（~）。
>
> 其中，默认构造函数和析构函数是必需的，其余构造函数根据需要而定。构造函数的**函数名都与类名相同**。但是，它们可以通过参数列表的不同来区分开来。因此，C++支持函数重载，允许在同一作用域内定义多个函数，只要它们的参数列表不同就可以。在构造函数中也可以利用这个机制定义多个构造函数，实现不同的功能。

## 2-28 

**题目：**下面关于析构函数的陈述哪个是正确的：
A. 对象所占用的空间要通过析构函数来释放
B. 析构函数名称与构造函数名称相同
C. 析构函数可以有参数
D. 可以没有析构函数

**答案：**A

## 2-29 

**题目：**关于下面代码的陈述哪些是错误的：

```c++
Clock c；
Clock *pc1=new Clock;
Clock *pc2=&c;
```

其中Clock是一个类。
A. 创建了两个Clock对象
B. 创建了三个Clock对象
C. pc1和pc2指向了不同的对象
D. delete pc1会释放一个对象

**答案：**B

## 2-30 

**题目：**关于下面代码的陈述哪些是错误的：

```c++
Clock c；
Clock *pc1=new Clock;
Clock *pc2=&c;
pc1=pc2;
```

A. 调用了Clock的默认构造函数创建了对象c
B. pc1指向了对象c
C. pc2指向了对象c
D. 调用两次Clock的析构函数

**答案：**D

> **说明：**根据代码，对象 `c` 是通过默认构造函数创建的，而对象 `pc1` 则是通过动态内存分配 `new` 运算符创建的。当 `pc1` 指向 `c` 之后，两个指针都指向了同一个 `Clock` 对象。在 `pc1` 指向 `c` 之后，`pc1` 之前指向的动态分配的内存没有被释放，也就是说不会调用析构函数。
>
> 当程序运行结束后，仅析构了`c`对象，而没有析构之前`pc1`指向的对象。仅调用了一次Clock的析构函数。

## 2-31 

**题目：**下面关于继承的陈述哪些是错误的：
A. 一个类可以继承多个基类
B. 一个类可以继承同一个类多次
C. 可以继承构造函数
D. 不可以继承析构函数

**答案：**C

> **说明：**
>
> A选项：多重继承。
>
> B选项：一个类可以继承同一个类多次是指在一个类的定义中，可以多次使用同一个基类，如下面的示例代码所示：
>
> ```c++
> class A {
> public:
>     int a;
> };
> 
> class B : public A {
> public:
>     int b;
> };
> 
> class C : public A {
> public:
>     int c;
> };
> 
> class D : public B, public C {
> public:
>     int d;
> };
> ```
>
> 在上面的示例中，类`D`同时继承了类`B`和类`C`，这两个类都直接或间接继承了类`A`。因此，`D`类实际上继承了类`A`两次。这种情况下，类`D`中将包含两个名为`a`的数据成员，但它们是独立的。可以通过作用域限定符来访问它们，如`D::B::a`和`D::C::a`。
>
> C选项：在 C++ 中，子类会自动继承父类的构造函数，但是并不是继承构造函数的实现代码，而是继承了构造函数的接口。这是因为构造函数具有特殊的属性，它们用于初始化对象的成员变量。如果子类直接继承了父类的构造函数实现代码，那么**它将初始化父类的成员变量，而子类新增的成员变量则无法被初始化**。因此，在子类中需要定义自己的构造函数来初始化子类新增的成员变量。同时，子类可以在自己的构造函数中调用父类的构造函数，以初始化从父类继承下来的成员变量。这种方式称为构造函数的调用链。因此，子类不需要继承构造函数的实现代码，而是需要定义自己的构造函数来满足自己的需要。
>
> D选项：在C++中，子类不会继承其父类的析构函数，而是会自动调用父类的析构函数来销毁其继承的成员变量。这是因为析构函数在C++中的作用是用来销毁对象的，而对象的销毁顺序是先销毁成员变量，再销毁对象本身。如果子类继承了父类的析构函数，就会导致**父类的成员变量被销毁两次，从而导致程序出现未定义行为**。因此，为了避免这种情况，C++规定子类不继承其父类的析构函数，而是自动调用父类的析构函数来销毁其继承的成员变量。

## 2-32 

**题目：**已知类A公有继承了类B，下面哪个陈述是错误的：
A. 类A包含了类B的所有数据成员
B. 类A可以直接调用类B的公有函数
C. 类A可以直接调用类B的保护函数
D. 类A可以直接访问类B的私有成员

**答案：**D

> 说明：不管怎样的继承方式都无法直接访问私有成员。
>
> | 继承方式 | 基类的公有成员 | 基类的保护成员 | 基类的私有成员 |
> | -------- | -------------- | -------------- | -------------- |
> | 公有继承 | 仍为公有成员   | 仍为保护成员   | 不可访问       |
> | 保护继承 | 变为保护成员   | 变为保护成员   | 不可访问       |
> | 私有继承 | 变为私有成员   | 变为私有成员   | 不可访问       |

## 2-33 

**题目：**已知类B保护继承了类A，类C保护继承了类B，下面哪些陈述是错误的：
A. 类C包含了类A的数据成员
B. 类C中可以直接调用类A的公有函数
C. 类C中可以直接调用类A的保护函数
D. 类C继承了类A的构造函数

**答案：**D

> **说明：**构造函数不可继承，详见2-31。

## 2-34 

**题目：**已知类C公有继承了类B，类B私有继承了类A，下面哪些陈述是错误的：
A. 类C中可以访问类A的公有函数
B. 类C中不可以访问类A的公有函数
C. 类C包含了类A数据成员
D. 类C可以访问类B的保护函数

**答案：**A

> **说明：**因为类B私有继承了类A，所以A的公有函数在B中为私有函数，C无法直接访问到该私有函数。详见2-32的表格。

## 2-35 

**题目：**在能够编译通过的情况下，关于下面代码的陈述哪一个是错误的：

```c++
class A {
    int a;
public:
    A(int aa) {
        a = aa;
    }
};
class B: public A {
	int b;
};
int main() {
	A a1;
	B b1;
	return 0;
}
```

A. 类A需要一个无参构造函数
B. 可以给类B添加一个无参构造函数
C. 可以给类B增加一个有参构造函数
D. 类B不可以直接访问类A中的数据成员a

**答案：**C

> **说明：**
>
> A选项：因为A创建了有参构造函数，所以无参构造函数就自动去除了，所以需要自己定义一个。不然语句`A a1;`就会出错。
>
> B选项：因为B继承A所以没有默认构造函数，需要自己创建，不然语句`B b1;`会出错。
>
> C选项：没必要。
>
> D选项：公有继承也不能访问私有变量，详见2-32表格。

## 2-36 

**题目：**下面哪些关于派生类和基类的陈述是错误的：
A. 派生类对象可以转换为基类对象
B. 基类对象可以转换为派生类对象
C. 基类对象指针可以指向派生类对象
D. 可以用派生类对象初始化基类对象的引用

**答案：**B

> **说明：**基类对象不能转成派生类，因为派生类中有一些基类不含的成员。直接转换的话这些成员都没有定义。

## 2-37 

**题目：**下面关于类的成员的叙述哪个是错误的：
A. 类的静态成员可以使用类名访问
B. 类的静态成员可以使用对象名访问
C. 在类的静态函数中可以使用this指针
D. 类的静态函数不可以直接访问类的非静态成员

**答案：**C

> **说明：**类的静态函数/成员都是所有类共有的（一起使用的），所以当然不能使用this指针（因为不知道this指的哪个）。

## 2-38 

**题目：**下面关于派生类的构造和析构的叙述哪个是错误的：
A. 构造派生类的对象时需要调用基类的构造函数
B. 构造派生类的对象时需要调用内嵌对象的构造函数
C. 派生类对象析构时，先执行基类的析构函数再执行派生类的析构函数
D. 先执行派生类的析构函数，再执行内嵌对象的析构函数

**答案：**C

> **说明：**在C++程序中，对象的创建到销毁的整个流程如下：
>
> 1. 为对象分配内存空间：在对象创建之前，需要分配内存空间来存储对象的数据成员。
> 2. 调用构造函数：分配内存空间后，需要调用构造函数来对对象进行初始化。构造函数将对象的数据成员进行初始化，包括对基类和内嵌对象的初始化。
> 3. 对象使用：创建后的对象可以通过成员函数等方式进行使用。
> 4. 调用析构函数：当对象不再使用时，程序需要调用析构函数来清理对象占用的内存空间，以避免内存泄漏。
> 5. 释放内存空间：最后，程序需要释放对象占用的内存空间，以便其他对象或者程序可以使用。
>
> 需要注意的是，在对象的创建和销毁过程中，如果有基类或者内嵌对象，那么这些基类或内嵌对象的构造和析构函数也会被调用。一般来说，**基类的构造函数会在派生类的构造函数之前调用，而析构函数的执行顺序则与构造函数相反。**

## 2-39 

**题目：**下面关于虚函数的叙述哪个是错误的：
A. 构造函数可以定义为虚函数
B. 析构函数可以定义为虚函数
C. 包含纯虚函数的类不能创建对象
D. 包含纯虚函数的类为抽象类

**答案：**A

> **说明：**构造函数不能是虚函数是因为在对象创建时，先要调用基类构造函数，再调用派生类构造函数。这个调用顺序是在编译期就确定的，而虚函数的调用是在运行时确定的，因为虚函数是根据对象的实际类型来决定调用哪个版本的函数。因此，如果将构造函数定义为虚函数，就会破坏这个顺序，导致编译器无法正确地生成对象的构造代码。因此，C++规定构造函数不能是虚函数。
>
> - 若析构函数是虚函数，delete 时，基类和子类都会被释放；
> - 若析构函数不是虚函数，delete 时，只有基类会被释放，而子类没有释放，存在内存泄漏的隐患。

## 2-40 

**题目：**下面哪个不是实现运行时多态的条件：

A. 需要一个指向基类对象的指针调用和基类成员函数同名的派生类成员函数
B. 派生类的继承方式必须是公有继承
C. 基类中的同名函数必须定义为虚函数
D. 把构造函数声明为虚函数

**答案：**D

> **说明：**解释见2-39。

## 2-41 

**题目：**下面关于结构类型的叙述哪些是错误的：
A. 结构可以包含不同类型的数据成员
B. 可以在结构内部定义一个指向同类型结构的指针
C. 结构不能有函数成员
D. 不同类型的结构变量不能相互赋值

**答案：**C

## 2-42 

**题目：**需要输出一个字符串“hello”，不可以直接调用一次就完成的语句是：
A. cout<<"hello";
B. printf("hello");
C. putchar("hello");
D. puts("hello");

**答案：**C

## 2-43 

**题目：**程序的三种控制结构不包括：
A. 顺序结构
B. 选择结构
C. 循环结构
D. 模块结构

**答案：**D

## 2-44 

**题目：**不能实现循环结构的语句是：
A. do-while
B. while
C. switch
D. for

**答案：**C

## 2-45 

**题目：**定义包含5个元素的数组的不正确方式是：
A. int a[]={5};
B. int a[5];
C. int a[5]={0};
D. int* a=new int[5];

**答案：**A

## 2-46 

**题目：**下面定义二维数组的语句中，哪个是错误的：

A. 

```
int a[][4] = {{4, 2}, {1, 2}};
```

B. 

```
int a[2][] = {{4, 2}, {1, 2}};
```

C. 

```
int a[3][4] = {{4, 2}, {1, 2}};
```

D. 

```
int a[3][4] = {0};
```

**答案：**B

> **说明：**选项B中的语句是错误的，因为在定义二维数组时，只有第一维的长度可以省略，第二维的长度必须指定，否则编译器无法分配内存空间。因此，选项B中的语句不符合语法规则，是错误的。

## 2-47 

**题目：**下面关于结构体和联合体的叙述哪个是错误的：
A. 结构体的成员可以有不同的数据类型
B. 同类型的结构体之间可以整体赋值
C. 结构体可以嵌套结构体
D. 结构体内不能嵌套联合体

**答案：**D

## 2-48 

**题目：**下面关于联合类型的陈述哪个是错误的：
A. 在某时刻，只能使用联合的多个成员的其中之一
B. 联合变量的地址和他的各个成员的地址不同
C. 不能对联合变量名赋值
D. 不能用联合变量作为函数返回值

**答案：**B

> 联合变量是一种特殊的变量类型，可以在同一个内存空间中存储多种不同类型的数据，但同一时刻只能使用其中的一个成员。它和结构体相似，但不同之处在于结构体中的各个成员是独立的，而**联合中的成员共享同一块内存空间**。
>
> 以下是一个简单的联合变量示例：
>
> ```c++
> #include <iostream>
> using namespace std;
> 
> union MyUnion {
>   int i;
>   float f;
>   char c;
> };
> 
> int main() {
>   MyUnion u;
>   u.i = 42;
>   cout << "u.i: " << u.i << endl; // 输出 42
>   u.f = 3.14;
>   cout << "u.f: " << u.f << endl; // 输出 3.14
>   u.c = 'A';
>   cout << "u.c: " << u.c << endl; // 输出 A
>   cout << "u.i: " << u.i << endl; // 输出 65，即字符'A'的 ASCII 码
>   return 0;
> }
> ```
>
> 在这个例子中，我们定义了一个名为`MyUnion`的联合类型，包含了一个整型变量`i`、一个浮点型变量`f`和一个字符型变量`c`。在`main`函数中，我们创建了一个`MyUnion`类型的变量`u`，并依次给它的三个成员赋值。可以看到，每次给成员赋值时，原先存储在内存中的数据都会被覆盖，因为联合中的成员共享同一块内存空间。

## 2-49 

**题目：**和下面函数不是重载关系的函数是：

```
int f1();
```

A. 

```
int f1(int a, int b);
```

B. 

```
int f1(int a);
```

C. 

```
int f1(int a, int b, int c);
```

D. 

```
double f1();
```

**答案：**D

## 2-50 

**题目：**下面关于指针的叙述哪个是错误的：
A. 存放地址的变量称为指针变量
B. 指针变量必须在初始化后才可以正确使用
C. 两个同类型的指针变量可以直接相加
D. 指针变量可以直接和一个整数做加法或者减法运算

**答案：**C

> **说明：**两个同类型的指针变量可以做减法，表示它们之间的地址差，但不能直接相加。因为相加没有实际意义，两个指针变量相加得到的是两个指针地址相加的和，而这个和不一定是一个有效的地址。正确的叙述应该是：“两个同类型的指针变量可以做减法运算，表示它们之间的地址差。”
>
> D选项中，与整数做加法和减法表示地址偏移。

## 2-51 

**题目：**下面能够直接执行的程序是：
A. 源程序
B. 目标程序
C. 函数库
D. 翻译程序

**答案：**D

> **说明：**`.cpp`文件表示源程序，`.o`文件表示目标程序，函数库不是程序，以上都不可直接执行。
>
> 通过翻译程序将目标程序转换成可执行文件`.exe`, `.out`或其他即可执行。本题表述不清楚，也可以理解成“语言翻译程序”😓。

## 2-52 

**题目：**下面关于异常处理的叙述哪个是错误的：
A. 可能出现异常的语句放入try语句块
B. catch语句可以捕获一种类型的异常
C. 不能自定义异常类型
D. 可以有多个catch语句

**答案：**C

## 2-53 

**题目：**下面哪些情况不属于C++异常处理中的异常情况：
A. 程序运行时，因内存不足，不能动态申请内存空间。
B. 因程序逻辑错误不能得到期望的结果。
C. 程序运行时，不能打开新的输出文件。
D. 程序运行时，发生除数为0的情况。

**答案：**B

## 2-54 

**题目：**下面有关异常的说法哪些是错误的：

A. 异常是程序在运行时可能出现的会导致程序运行终止的错误
B. 程序的语法错误不是异常
C. 程序运行时，参数类型不能正常转换不属于异常情况
D. 程序运行时，数组越界属于异常情况

**答案：**C

> **说明：**异常是指程序在运行时可能出现的，导致程序无法正常执行的错误。与语法错误不同，异常是在程序运行时出现的错误，而不是在编译时发现的错误。程序运行时，参数类型不能正常转换时不属于异常情况，而是属于程序错误的类型之一，需要在代码中显式处理。数组越界、除数为零、内存不足等都属于异常情况。



# 多选题（2题，每题5分，共10分）

## 3-1 

**题目：**面向对象程序设计的三大特性是什么？
A. 封装
B. 继承
C. 多态
D. 函数

**答案：**ABC

## 3-2 

**题目：**设变量已正确定义，选项（ ）与以下程序段不等价。

```c++
switch(choice){
      case 1: price = 3.0;
      case 2: price = 2.5;
      default: price = 0.0;
}
```

A. 

```c++
price = 0.0;
```

B. 

```c++
switch(choice){
      default: price = 0.0;
      case 2: price = 2.5;
      case 1: price = 3.0;
}
```

C.

```c++
price = 0.0;
switch(choice){
      case 1: price = 3.0;
      case 2: price = 2.5;
}
```

D. 

```c++
if(choice == 1){
      price = 3.0; price = 2.5; price = 0.0;
}else if(choice == 2){
      price = 2.5; price = 0.0;
}else{
      price = 0.0;
}
```

**答案：**BC

> **说明：**因为程序里每个`case`后没写`break`，因此都会走到最后一句`price=0.0`，所以只要看哪些程序段输出一直是`price=0.0`即可。显然AD都是，而BC不一定是。

## 3-3 

**题目：**算法（Algorithm）是一组明确的解决问题的步骤，它产生结果并可在有限的时间内终止。可以用（ ）多种方式来描述算法。
A. 自然语言
B. 伪代码
C. 流程图

**答案：**ABC

## 3-4 

**题目：**非空线性表的结构特征

非空线性表具有哪些结构特征？

A. 只有唯一的开始结点和唯一的终端结点

B. 可拥有多个的开始结点和多个终端结点

C. 除开始结点外，每个结点只有一个前驱结点

D. 除终端结点外，每个结点只有一个后继结点

**答案：**ACD

## 3-5 

**题目：**以下说法错误的是（   ）。   

A. 哈夫曼树是带权路径长度最短的树，路径上权值较大的结点离根较近。
B. 若一个二叉树的树叶是某子树的中序遍历序列中的第一个结点，则它必是该子树的后序遍历序列中的第一个结点
C. 已知二叉树的前序遍历和后序遍历序列并不能唯一确定这棵树，因为不知道树的根结点是哪一个。
D. 在前序遍历二叉树的序列中，任何结点的子树的所有结点都是直接跟在该结点之后。

**答案：**AC

> **说明：**
>
> A选项：这句话的前半部分是正确的，哈夫曼树是一种带权路径长度最短的树，但是后半部分“路径上权值较大的结点离根较近”不一定是正确的。在哈夫曼树中，权值较大的结点不一定离根较近，这取决于该结点在哈夫曼树中的位置和它的兄弟结点的权值大小关系。具体来说，哈夫曼树的构建过程是将权值较小的结点作为叶子结点，依次合并成新的父节点，并且**新的父节点的权值等于它的两个子节点的权值之和（大于一个权值较大的节点）。因此，权值较大的结点有可能在离根较远的位置**。所以，哈夫曼树中路径上权值较大的结点不一定离根较近，这是这句话的错误之处。
>
> B选项：中序遍历和后序遍历都是先遍历左边，所以第一个节点应该是一样的。
>
> C选项：虽然不能唯一确定这棵树，但可以确定根，为前序遍历的第一个元素，后序遍历的最后一个元素。
>
> D选项：因为前序遍历先遍历父节点再遍历子节点，所以正确。

## 3-6 

**题目：**下列排序算法的常规实现中，除去对原始数据的保存以外，哪些算法的额外空间复杂度是O(1)？
A. 冒泡
B. 选择
C. 归并
D. 快排
E. 堆排序

**答案：**ABE

> **说明：**
>
> 下面是常见排序算法的时间复杂度和空间复杂度的表格：
>
> | 算法名称 | 平均时间复杂度 | 最好时间复杂度  | 最坏时间复杂度  | 空间复杂度  | 稳定性 |
> | -------- | -------------- | --------------- | --------------- | ----------- | ------ |
> | 冒泡排序 | $O(n^2)$       | $O(n)$          | $O(n^2)$        | $O(1)$      | 稳定   |
> | 选择排序 | $O(n^2)$       | $O(n^2)$        | $O(n^2)$        | $O(1)$      | 不稳定 |
> | 插入排序 | $O(n^2)$       | $O(n)$          | $O(n^2)$        | $O(1)$      | 稳定   |
> | 希尔排序 | $O(n \log n)$  | $O(n \log^2 n)$ | $O(n \log^2 n)$ | $O(1)$      | 不稳定 |
> | 归并排序 | $O(n \log n)$  | $O(n \log n)$   | $O(n \log n)$   | $O(n)$      | 稳定   |
> | 快速排序 | $O(n \log n)$  | $O(n \log n)$   | $O(n^2)$        | $O(\log n)$ | 不稳定 |
> | 堆排序   | $O(n \log n)$  | $O(n \log n)$   | $O(n \log n)$   | $O(1)$      | 不稳定 |
> | 计数排序 | $O(n+k)$       | $O(n+k)$        | $O(n+k)$        | $O(k)$      | 稳定   |
> | 桶排序   | $O(n+k)$       | $O(n+k)$        | $O(n^2)$        | $O(n+k)$    | 稳定   |
> | 基数排序 | $O(d(n+k))$    | $O(d(n+k))$     | $O(d(n+k))$     | $O(n+k)$    | 稳定   |
>
> 其中，$n$ 表示待排序元素的个数，$k$ 表示元素的取值范围（即最大值与最小值的差值加 $1$），$d$ 表示元素的位数。排序算法的稳定性指的是对于具有相同关键字的元素，在排序后是否保持原有的相对位置关系。
>
> 注意到：**在堆排序中，排序过程是在原数组中进行的，因此不需要额外的数组来存储排序结果。**堆排序的主要操作是建立堆和调整堆，建立堆的过程中需要将原数组转化为堆，需要一定的空间，但这个空间是可以被原数组所覆盖的，因此并不需要额外的空间。

## 3-7 

**题目：**链表 - 时间复杂度

在包含 $$n$$ 个数据元素的链表中，▁▁▁▁▁ 的时间复杂度为 $$O(n)$$。

A. 访问第 $$i$$ 个数据元素
B. 在第 $$i \  (1 \leq i \leq n)$$ 个结点后插入一个新结点
C. 删除第 $$i \  (1 \leq i \leq n)$$ 个结点
D. 将 $$n$$ 个元素按升序排序

**答案：**ABC

> **说明：**找到一个查询/插入/删除的位置都需要$O(n)$。



# 编程题（4题，共60分）

## 7-1 比较大小

本题要求将输入的任意3个整数从小到大输出。

### 输入格式:

输入在一行中给出3个整数，其间以空格分隔。

### 输出格式:

在一行中将3个整数从小到大输出，其间以“->”相连。 

### 输入样例:

```in
4 2 8
```

### 输出样例:

```out
2->4->8
```

### 参考代码

```C++
#include <bits/stdc++.h>
using namespace std;

int main(){
    vector<int> a(3, 0);
    for(int i = 0; i < 3; i ++) cin >> a[i];
    sort(a.begin(), a.end());
    cout << a[0] << "->" << a[1] << "->" << a[2] << endl;
    return 0;
}
```

## 7-2 计算指数

真的没骗你，这道才是简单题 —— 对任意给定的不超过 10 的正整数 $$n$$，要求你输出 $$2^n$$。不难吧？

### 输入格式：

输入在一行中给出一个不超过 10 的正整数 $$n$$。

### 输出格式：

在一行中按照格式  `2^n = 计算结果`  输出 $$2^n$$ 的值。

### 输入样例：

```in
5
```

### 输出样例：

```out
2^5 = 32
```

### 参考代码

```C++
#include <bits/stdc++.h>
using namespace std;

int main(){
    int n; cin >> n;
    cout << "2^" << n << " = " << (1ll << n) << endl;
    return 0;
}
```

## 7-3 计算阶乘和

对于给定的正整数$$N$$，需要你计算 $$S = 1! + 2! + 3! + ... + N!$$。

### 输入格式：

输入在一行中给出一个不超过10的正整数$$N$$。

### 输出格式：

在一行中输出$$S$$的值。

### 输入样例：

```in
3
```

### 输出样例：

```out
9
```

### 参考代码

```C++
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

int main(){
    int n; cin >> n;
    ll ans = 0, temp = 1;
    for(int i = 1; i <= n; i ++) {
        temp *= i;
        ans += temp;
    }
    cout << ans << endl;
    return 0;
}
```

## 7-4 跟奥巴马一起画方块

美国总统奥巴马不仅呼吁所有人都学习编程，甚至以身作则编写代码，成为美国历史上首位编写计算机代码的总统。2014年底，为庆祝“计算机科学教育周”正式启动，奥巴马编写了很简单的计算机代码：在屏幕上画一个正方形。现在你也跟他一起画吧！

### 输入格式：

输入在一行中给出正方形边长$$N$$（$$3\le N\le 21$$）和组成正方形边的某种字符`C`，间隔一个空格。

### 输出格式：

输出由给定字符`C`画出的正方形。但是注意到行间距比列间距大，所以为了让结果看上去更像正方形，我们输出的行数实际上是列数的50%（四舍五入取整）。

### 输入样例：

```in
10 a
```

### 输出样例：

```out
aaaaaaaaaa
aaaaaaaaaa
aaaaaaaaaa
aaaaaaaaaa
aaaaaaaaaa
```

### 参考代码

```C++
#include <bits/stdc++.h>
using namespace std;

int main(){
    int n; 
    char c;
    cin >> n >> c;
    int row = (n + 1) / 2;
    for(int i = 0; i < row; i ++) {
        for(int j = 0; j < n; j ++) {
            cout << c;
        }
        cout << endl;
    }
    return 0;
}
```

## 7-5 计算天数

本题要求编写程序计算某年某月某日是该年中的第几天。

### 输入格式:

输入在一行中按照格式“yyyy/mm/dd”（即“年/月/日”）给出日期。注意：闰年的判别条件是该年年份能被4整除但不能被100整除、或者能被400整除。闰年的2月有29天。 

### 输出格式:

在一行输出日期是该年中的第几天。

### 输入样例1:

```in
2009/03/02
```

### 输出样例1:

```out
61
```

### 输入样例2:

```
2000/03/02
```

### 输出样例2:

```
62
```

**鸣谢湖北汽车工业学院袁科老师、用户潘明智补充数据！**

### 参考代码

```C++
#include <bits/stdc++.h>
using namespace std;

inline bool isrun(int y) {
    return (y % 4 == 0 && y % 100 != 0) || y % 400 == 0;
}

int main(){
    int y, m, d;
    scanf("%d/%d/%d", &y, &m, &d);
    int day[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    if(isrun(y)) day[1] = 29;
    int sum = 0;
    for(int i = 0; i < m - 1; i ++) sum += day[i];
    cout << sum + d << endl;
    return 0;
}
```

## 7-6 然后是几点

有时候人们用四位数字表示一个时间，比如 `1106` 表示 11 点零 6 分。现在，你的程序要根据起始时间和流逝的时间计算出终止时间。

读入两个数字，第一个数字以这样的四位数字表示当前时间，第二个数字表示分钟数，计算当前时间经过那么多分钟后是几点，结果也表示为四位数字。当小时为个位数时，没有前导的零，例如 5 点 30 分表示为 `530`；0 点 30 分表示为 `030`。注意，第二个数字表示的分钟数可能超过 60，也可能是负数。

### 输入格式：

输入在一行中给出 2 个整数，分别是四位数字表示的起始时间、以及流逝的分钟数，其间以空格分隔。注意：在起始时间中，当小时为个位数时，没有前导的零，即 5 点 30 分表示为 `530`；0 点 30 分表示为 `030`。流逝的分钟数可能超过 60，也可能是负数。

### 输出格式：

输出不多于四位数字表示的终止时间，当小时为个位数时，没有前导的零。题目保证起始时间和终止时间在同一天内。

### 输入样例：

```in
1120 110
```

### 输出样例：

```out
1310
```

**鸣谢燕山大学穆运峰老师、用户任钰补充数据！**

### 参考代码

```C++
#include <bits/stdc++.h>
using namespace std;

int main(){
    int n, p;
    cin >> n >> p;
    int h = n / 100, m = n % 100;
    int t = h * 60 + m + p;
    printf("%d%02d\n", (t /60), (t % 60));
    return 0;
}
```

## 7-7 人民币兑换

1元5角钱人民币兑换5分、2分和1分的硬币（每一种都要有）共100枚，会有很多种兑换方案。请编写程序给出各种兑换方案。

### 输入格式:

输入为一个正整数n，表示要求输出前n种可能的方案。方案的顺序，是按照5分硬币从少到多排列的。

### 输出格式:

显示前n种方案中5分、2分、1分硬币各多少枚。每行显示一种方案，数字之间空一格，最后一个数字后没有空格。

注意：如果全部方案不到n种，就顺序输出全部可能的方案。

### 输入样例:

```in
5
```

### 输出样例:

```out
1 46 53  
2 42 56  
3 38 59  
4 34 62  
5 30 65
```

### 参考代码

```C++
#include <bits/stdc++.h>
using namespace std;

int main(){
    int n, cnt = 0;
    cin >> n;
    if(n == 0) return 0;
    for(int i = 1; i <= 30; i ++) {
        for(int j = 1; j <= 75; j ++) {
            int k = 100 - (i + j);
            if(k >= 1 && (i * 5 + j * 2 + k == 150)) {
                cout << i << " " << j << " " << k << endl;
                cnt += 1;
                if(cnt >= n) return 0;
            }
        }
    }
    return 0;
}
```

## 7-8 正整数A+B

题的目标很简单，就是求两个正整数`A`和`B`的和，其中`A`和`B`都在区间[1,1000]。稍微有点麻烦的是，输入并不保证是两个正整数。

### 输入格式：

输入在一行给出`A`和`B`，其间以空格分开。问题是`A`和`B`不一定是满足要求的正整数，有时候可能是超出范围的数字、负数、带小数点的实数、甚至是一堆乱码。

注意：我们把输入中出现的第1个空格认为是`A`和`B`的分隔。题目保证至少存在一个空格，并且`B`不是一个空字符串。

### 输出格式：

如果输入的确是两个正整数，则按格式`A + B = 和`输出。如果某个输入不合要求，则在相应位置输出`?`，显然此时和也是`?`。

### 输入样例1：

```in
123 456
```

### 输出样例1：

```out
123 + 456 = 579
```

### 输入样例2：

```
22. 18
```

### 输出样例2：

```
? + 18 = ?
```

### 输入样例3：

```
-100 blabla bla...33
```

### 输出样例3：

```
? + ? = ?
```

### 参考代码

```C++
#include <bits/stdc++.h>
using namespace std;

int transfer(string& s) {
    int ans = 0;
    for(char& c : s) {
        if(c >= '0' && c <= '9') ans = ans * 10 + (c - '0');
        else return -1;
        if(ans > 1000) return -1;
    }
    if(ans >= 1 && ans <= 1000) return ans;
    else return -1;
}

int main(){
    string s;
    getline(cin, s);
    string a = s.substr(0, s.find(' ')), b = s.substr(s.find(' ') + 1, s.size());
    int x = transfer(a), y = transfer(b);
    if(x != -1) {
        if(y != -1) {
            cout << x << " + " << y << " = " << x + y << endl;
        } else {
            cout << x << " + " << "?" << " = " << "?" << endl;
        }
    }else {
        if(y != -1) {
            cout << "?" << " + " << y << " = " << "?" << endl;
        } else {
            cout << "?" << " + " << "?" << " = " << "?" << endl;
        }
    }
    return 0;
}
```

## 7-9 个位数统计

给定一个 $$k$$ 位整数 $$N = d_{k-1}10^{k-1} + \cdots + d_1 10^1 + d_0$$ ($$0\le d_i \le 9$$, $$i=0,\cdots ,k-1$$, $$d_{k-1}>0$$)，请编写程序统计每种不同的个位数字出现的次数。例如：给定 $$N = 100311$$，则有 2 个 0，3 个 1，和 1 个 3。

### 输入格式：

每个输入包含 1 个测试用例，即一个不超过 1000 位的正整数 $$N$$。

### 输出格式：

对 $$N$$ 中每一种不同的个位数字，以 `D:M` 的格式在一行中输出该位数字 `D` 及其在 $$N$$ 中出现的次数 `M`。要求按 `D` 的升序输出。

### 输入样例：

```in
100311
```

### 输出样例：

```out
0:2
1:3
3:1
```

### 参考代码

```C++
#include <bits/stdc++.h>
using namespace std;

int main(){
    string s;
    cin >> s;
    vector<int> a(10, 0);
    for(char& c : s) a[c - '0'] ++;
    for(int i = 0; i < 10; i ++) if(a[i]) cout << i << ":" << a[i] << endl;
    return 0;
}
```

## 7-10 考试座位号

每个 PAT 考生在参加考试时都会被分配两个座位号，一个是试机座位，一个是考试座位。正常情况下，考生在入场时先得到试机座位号码，入座进入试机状态后，系统会显示该考生的考试座位号码，考试时考生需要换到考试座位就座。但有些考生迟到了，试机已经结束，他们只能拿着领到的试机座位号码求助于你，从后台查出他们的考试座位号码。

### 输入格式：

输入第一行给出一个正整数 $$N$$（$$\le 1000$$），随后 $$N$$ 行，每行给出一个考生的信息：`准考证号 试机座位号 考试座位号`。其中`准考证号`由 16 位数字组成，座位从 1 到 $$N$$ 编号。输入保证每个人的准考证号都不同，并且任何时候都不会把两个人分配到同一个座位上。

考生信息之后，给出一个正整数 $$M$$（$$\le N$$），随后一行中给出 $$M$$ 个待查询的试机座位号码，以空格分隔。

### 输出格式：

对应每个需要查询的试机座位号码，在一行中输出对应考生的准考证号和考试座位号码，中间用 1 个空格分隔。

### 输入样例：

```in
4
3310120150912233 2 4
3310120150912119 4 1
3310120150912126 1 3
3310120150912002 3 2
2
3 4
```

### 输出样例：

```out
3310120150912002 2
3310120150912119 1
```

### 参考代码

```C++
#include <bits/stdc++.h>
using namespace std;

int main(){
    int n, m, snum, knum, x;
    string s;
    cin >> n;
    vector<pair<string, int>> a(n);
    for(int i = 0; i < n; i ++) {
        cin >> s >> snum >> knum;
        a[snum - 1] = {s, knum};
    }
    cin >> m;
    while(m--) {
        cin >> x;
        auto [ss, nn] = a[x - 1];
        cout << ss << " " << nn << endl;
    }
    
    return 0;
}
```

## 7-11 念数字

输入一个整数，输出每个数字对应的拼音。当整数为负数时，先输出`fu`字。十个数字对应的拼音如下：

```
0: ling
1: yi
2: er
3: san
4: si
5: wu
6: liu
7: qi
8: ba
9: jiu
```

### 输入格式：

输入在一行中给出一个整数，如：`1234`。

<b>提示：整数包括负数、零和正数。</b>

### 输出格式：

在一行中输出这个整数对应的拼音，每个数字的拼音之间用空格分开，行末没有最后的空格。如
`yi er san si`。

### 输入样例：

```in
-600
```

### 输出样例：

```out
fu liu ling ling
```

### 参考代码

```C++
#include <bits/stdc++.h>
using namespace std;

int main(){
    unordered_map<char, string> mp = {
        {'0', "ling"},
        {'1', "yi"},
        {'2', "er"},
        {'3', "san"},
        {'4', "si"},
        {'5', "wu"},
        {'6', "liu"},
        {'7', "qi"},
        {'8', "ba"},
        {'9', "jiu"},
        {'-', "fu"}
    };
    string s;
    cin >> s;
    bool flag = false;
    for(char& c : s) {
        if(flag) cout << " ";
        else flag = true;
        cout << mp[c];
    }
    return 0;
}
```

## 7-12 检查密码

本题要求你帮助某网站的用户注册模块写一个密码合法性检查的小功能。该网站要求用户设置的密码必须由不少于6个字符组成，并且只能有英文字母、数字和小数点 `.`，还必须既有字母也有数字。


### 输入格式：

输入第一行给出一个正整数 N（$$\le$$ 100），随后 N 行，每行给出一个用户设置的密码，为不超过 80 个字符的非空字符串，以回车结束。

**注意：** 题目保证不存在只有小数点的输入。

### 输出格式：

对每个用户的密码，在一行中输出系统反馈信息，分以下5种：

- 如果密码合法，输出`Your password is wan mei.`；
- 如果密码太短，不论合法与否，都输出`Your password is tai duan le.`；
- 如果密码长度合法，但存在不合法字符，则输出`Your password is tai luan le.`；
- 如果密码长度合法，但只有字母没有数字，则输出`Your password needs shu zi.`；
- 如果密码长度合法，但只有数字没有字母，则输出`Your password needs zi mu.`。

### 输入样例：

```in
5
123s
zheshi.wodepw
1234.5678
WanMei23333
pass*word.6

```

### 输出样例：

```out
Your password is tai duan le.
Your password needs shu zi.
Your password needs zi mu.
Your password is wan mei.
Your password is tai luan le.
```

### 参考代码

```C++
#include <bits/stdc++.h>
using namespace std;

inline bool judgealpha(char& c) {
    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
}

inline bool judgenum(char& c) {
    return (c >= '0' && c <= '9');
}

inline bool judgedot(char& c) {
    return c == '.';
}

string solve() {
    string s;
    getline(cin, s);
//     cout << s << endl;
    if(s.size() < 6) return "Your password is tai duan le.";
    bool flagnum = false, flagalpha = false;
    for(char& c : s) {
        if(judgenum(c)) flagnum = true;
        else if(judgealpha(c)) flagalpha = true;
        else if(!judgedot(c)) return "Your password is tai luan le.";
    }
    if(flagnum && flagalpha) return "Your password is wan mei.";
    else if(!flagnum) return "Your password needs shu zi.";
    else if(!flagalpha) return "Your password needs zi mu.";
}

int main(){
    int t;
    cin >> t;
    string temp;
    getline(cin, temp);
    while(t --) cout << solve() << endl;
    return 0;
}
```

## 7-13 谁是赢家

某电视台的娱乐节目有个表演评审环节，每次安排两位艺人表演，他们的胜负由观众投票和 3 名评委投票两部分共同决定。规则为：如果一位艺人的观众票数高，且得到至少 1 名评委的认可，该艺人就胜出；或艺人的观众票数低，但得到全部评委的认可，也可以胜出。节目保证投票的观众人数为奇数，所以不存在平票的情况。本题就请你用程序判断谁是赢家。

### 输入格式：

输入第一行给出 2 个不超过 1000 的正整数 Pa 和 Pb，分别是艺人 a 和艺人 b 得到的观众票数。题目保证这两个数字不相等。随后第二行给出 3 名评委的投票结果。数字 0 代表投票给 a，数字 1 代表投票给 b，其间以一个空格分隔。

### 输出格式：

按以下格式输出赢家：

```
The winner is x: P1 + P2
```

其中 `x` 是代表赢家的字母，`P1` 是赢家得到的观众票数，`P2` 是赢家得到的评委票数。

### 输入样例：

```in
327 129
1 0 1
```

### 输出样例：

```out
The winner is a: 327 + 1
```

**鸣谢安阳师范学院软件学院李栋同学完善测试数据。**

### 参考代码

```C++
#include <bits/stdc++.h>
using namespace std;

int main(){
    int pa, pb, n1, n2, n3;
    cin >> pa >> pb >> n1 >> n2 >> n3;
    if(pa > pb) {
        int num = (n1 == 0) + (n2 == 0) + (n3 == 0);
        if(num > 0) cout << "The winner is a: " << pa << " + " << num << endl;
        else cout << "The winner is b: " << pb << " + " << 3 << endl;
    }else {
        int num = (n1 == 1) + (n2 == 1) + (n3 == 1);
        if(num > 0) cout << "The winner is b: " << pb << " + " << num << endl;
        else cout << "The winner is a: " << pa << " + " << 3 << endl;
    }
    return 0;
}
```

## 7-14 不变初心数

不变初心数是指这样一种特别的数，它分别乘 2、3、4、5、6、7、8、9 时，所得乘积各位数之和却不变。例如 18 就是这样的数：18 的 2 倍是 36，3+6=9；18 的 3 倍是 54，5+4=9；…… 18 的 9 倍是 162，1+6+2=9。对于 18 而言，9 就是它的初心。本题要求你判断任一个给定的数是否有不变的初心。

### 输入格式：

输入在第一行中给出一个正整数 N（$$\le$$ 100）。随后 N 行，每行给出一个不超过 $$10^5$$ 的正整数。

### 输出格式：

对每个给定的数字，如果它有不变的初心，就在一行中输出它的初心；否则输出 `NO`。

### 输入样例：

```in
4
18
256
99792
88672
```

### 输出样例：

```out
9
NO
36
NO
```

### 参考代码

```C++
#include <bits/stdc++.h>
using namespace std;

int getnum(int x) {
    int num = 0;
    while(x) {
        num += x % 10;
        x /= 10;
    }
    return num;
}

int solve() {
    int n = 0;
    cin >> n;
    int ans = -1;
    for(int i = 2; i <= 9; i ++) {
        int temp = getnum(n * i);
        if(ans == -1) ans = temp;
        if(ans != temp) return -1;
    }
    return ans;
}

int main(){
    int t = 0;
    cin >> t;
    while(t--) {
        int num = solve();
        if(num == -1) cout << "NO" << endl;
        else cout << num << endl;
    }
    
    return 0;
}
```

## 7-15 新胖子公式

根据钱江晚报官方微博的报导，最新的肥胖计算方法为：体重(kg) / 身高(m) 的平方。如果超过 25，你就是胖子。于是本题就请你编写程序自动判断一个人到底算不算胖子。

### 输入格式：

输入在一行中给出两个正数，依次为一个人的体重（以 kg 为单位）和身高（以 m 为单位），其间以空格分隔。其中体重不超过 1000 kg，身高不超过 3.0 m。

### 输出格式：

首先输出将该人的体重和身高代入肥胖公式的计算结果，保留小数点后 1 位。如果这个数值大于 25，就在第二行输出 `PANG`，否则输出 `Hai Xing`。

### 输入样例 1：

```in
100.1 1.74
```

### 输出样例 1：

```out
33.1
PANG
```

### 输入样例 2：

```in
65 1.70
```

### 输出样例 2：

```out
22.5
Hai Xing
```

### 参考代码

```C++
#include <bits/stdc++.h>
using namespace std;

int main(){
    float x, y;
    cin >> x >> y;
    float ans = x / y / y;
    printf("%.1f\n", ans);
    if(ans > 25) cout << "PANG" << endl;
    else cout << "Hai Xing" << endl;
    return 0;
}
```

## 7-16 幸运彩票

彩票的号码有 6 位数字，若一张彩票的前 3 位上的数之和等于后 3 位上的数之和，则称这张彩票是幸运的。本题就请你判断给定的彩票是不是幸运的。

### 输入格式：

输入在第一行中给出一个正整数 N（$$\le$$ 100）。随后 N 行，每行给出一张彩票的 6 位数字。

### 输出格式：

对每张彩票，如果它是幸运的，就在一行中输出 `You are lucky!`；否则输出 `Wish you good luck.`。

### 输入样例：

```in
2
233008
123456
```

### 输出样例：

```out
You are lucky!
Wish you good luck.
```

### 参考代码

```C++
#include <bits/stdc++.h>
using namespace std;

void solve() {
    int n;
    cin >> n;
    int a = n / 1000, b = n % 1000;
    if(a / 100 + a % 100 / 10 + a % 10 == b / 100 + b % 100 / 10 + b % 10){
        cout << "You are lucky!" << endl;
    }else cout << "Wish you good luck." << endl;
}

int main(){
    int t;
    cin >> t;
    while(t --) solve();
    return 0;
}
```

## 7-17 降价提醒机器人

小 T 想买一个玩具很久了，但价格有些高，他打算等便宜些再买。但天天盯着购物网站很麻烦，请你帮小 T 写一个降价提醒机器人，当玩具的当前价格比他设定的价格便宜时发出提醒。


### 输入格式：

输入第一行是两个正整数 $$N$$ 和 $$M$$ ($$1 \le N \le 100, 0 \le M \le 1000$$)，表示有 $$N$$ 条价格记录，小 T 设置的价格为 $$M$$。

接下来 $$N$$ 行，每行有一个实数 $$P_i$$（$$-1000.0 < P_i < 1000.0$$），表示一条价格记录。

### 输出格式：

对每一条比设定价格 $$M$$ 便宜的价格记录 `P`，在一行中输出 `On Sale! P`，其中 `P` 输出到小数点后 1 位。

### 输入样例：

```in
4 99
98.0
97.0
100.2
98.9
```

### 输出样例：

```out
On Sale! 98.0
On Sale! 97.0
On Sale! 98.9
```

### 参考代码

```C++
#include <bits/stdc++.h>
using namespace std;

int main(){
    int n, m;
    cin >> n >> m;
    float t;
    while(n --) {
        cin >> t;
        if(t < m) printf("On Sale! %.1f\n", t);
    }
    return 0;
}
```

## 7-18 胎压监测

小轿车中有一个系统随时监测四个车轮的胎压，如果四轮胎压不是很平衡，则可能对行车造成严重的影响。


![taiya.JPG](C:\Users\Yipeng\Programming\ProfessionalBasicAptitudeTest\Practice\~\66539c6c-cd86-4bbb-a15c-d00828719f75.JPG)


让我们把四个车轮 —— 左前轮、右前轮、右后轮、左后轮 —— 顺次编号为 1、2、3、4。本题就请你编写一个监测程序，随时监测四轮的胎压，并给出正确的报警信息。报警规则如下：

- 如果所有轮胎的压力值与它们中的最大值误差在一个给定阈值内，并且都不低于系统设定的最低报警胎压，则说明情况正常，不报警；
- 如果存在一个轮胎的压力值与它们中的最大值误差超过了阈值，或者低于系统设定的最低报警胎压，则不仅要报警，而且要给出可能漏气的轮胎的准确位置；
- 如果存在两个或两个以上轮胎的压力值与它们中的最大值误差超过了阈值，或者低于系统设定的最低报警胎压，则报警要求检查所有轮胎。

### 输入格式：

输入在一行中给出 6 个 [0, 400] 范围内的整数，依次为 1~4 号轮胎的胎压、最低报警胎压、以及胎压差的阈值。

### 输出格式：

根据输入的胎压值给出对应信息：

- 如果不用报警，输出 `Normal`；
- 如果有一个轮胎需要报警，输出 `Warning: please check #X!`，其中 `X` 是出问题的轮胎的编号；
- 如果需要检查所有轮胎，输出 `Warning: please check all the tires!`。

### 输入样例 1：

```in
242 251 231 248 230 20
```

### 输出样例 1：

```out
Normal
```

### 输入样例 2：

```in
242 251 232 248 230 10
```

### 输出样例 2：

```out
Warning: please check #3!
```

### 输入样例 3：

```in
240 251 232 248 240 10
```

### 输出样例 3：

```out
Warning: please check all the tires!
```

### 参考代码

```C++
#include <bits/stdc++.h>
using namespace std;

int main(){
    vector<int> a(4);
    int n1, n2, maxn = -1;
    vector<int> w;
    for(int i = 0; i < 4; i ++) {
        cin >> a[i];
        if(a[i] > maxn) maxn = a[i];
    }
    cin >> n1 >> n2;
    for(int i = 0; i < 4; i ++) {
        if(maxn - a[i] > n2 || a[i] < n1) w.push_back(i);
    }
    if(w.size() == 0) cout << "Normal" << endl;
    else if(w.size() == 1) cout << "Warning: please check #" << w[0] + 1 << "!" << endl;
    else cout << "Warning: please check all the tires!" << endl;
    return 0;
}
```

## 7-19 大笨钟的心情

![心情.jpg](C:\Users\Yipeng\Programming\ProfessionalBasicAptitudeTest\Practice\~\8c3b8713-1703-4e56-addb-492f738c3a7c.jpg)


有网友问：未来还会有更多大笨钟题吗？笨钟回复说：看心情……

本题就请你替大笨钟写一个程序，根据心情自动输出回答。

### 输入格式：

输入在一行中给出 24 个 [0, 100] 区间内的整数，依次代表大笨钟在一天 24 小时中，每个小时的心情指数。

随后若干行，每行给出一个 [0, 23] 之间的整数，代表网友询问笨钟这个问题的时间点。当出现非法的时间点时，表示输入结束，这个非法输入不要处理。题目保证至少有 1 次询问。

### 输出格式：

对每一次提问，如果当时笨钟的心情指数大于 50，就在一行中输出 `心情指数 Yes`，否则输出 `心情指数 No`。

### 输入样例：

```in
80 75 60 50 20 20 20 20 55 62 66 51 42 33 47 58 67 52 41 20 35 49 50 63
17
7
3
15
-1
```

### 输出样例：

```out
52 Yes
20 No
50 No
58 Yes
```

### 参考代码

```C++
#include <bits/stdc++.h>
using namespace std;

int main(){
    vector<int> a(24);
    for(int i = 0; i < 24; i ++) cin >> a[i];
    int t;
    while(cin >> t) {
        if(t < 0 || t > 23) break;
        cout << a[t] << (a[t] > 50 ? " Yes" : " No") << endl;
    }
    return 0;
}
```

## 7-20 统计工龄

给定公司$$N$$名员工的工龄，要求按工龄增序输出每个工龄段有多少员工。

### 输入格式:

输入首先给出正整数$$N$$（$$\le 10^5$$），即员工总人数；随后给出$$N$$个整数，即每个员工的工龄，范围在[0, 50]。

### 输出格式:

按工龄的递增顺序输出每个工龄的员工个数，格式为：“工龄:人数”。每项占一行。如果人数为0则不输出该项。

### 输入样例:

```in
8
10 2 0 5 7 2 5 2
```

### 输出样例:

```out
0:1
2:3
5:2
7:1
10:1
```

### 参考代码

```C++
#include <bits/stdc++.h>
using namespace std;

int main(){
    int n, x;
    cin >> n;
    map<int, int> mp;
    for(int i = 0; i < n; i ++) {
        cin >> x;
        mp[x] ++;
    }
    for(auto& [x, y] : mp) {
        cout << x << ":" << y << endl;
    }
    return 0;
}
```

## 7-22 符号配对

请编写程序检查C语言源程序中下列符号是否配对：`/*`与`*/`、`(`与`)`、`[`与`]`、`{`与`}`。

### 输入格式:

输入为一个C语言源程序。当读到某一行中只有一个句点`.`和一个回车的时候，标志着输入结束。程序中需要检查配对的符号不超过100个。

### 输出格式:

首先，如果所有符号配对正确，则在第一行中输出`YES`，否则输出`NO`。然后在第二行中指出第一个不配对的符号：如果缺少左符号，则输出`?-右符号`；如果缺少右符号，则输出`左符号-?`。

### 输入样例1：

```in
void test()
{
    int i, A[10];
    for (i=0; i<10; i++) { /*/
        A[i] = i;
}
.

```

### 输出样例1：

```out
NO
/*-?

```

### 输入样例2：

```
void test()
{
    int i, A[10];
    for (i=0; i<10; i++) /**/
        A[i] = i;
}]
.

```

### 输出样例2：

```
NO
?-]

```

### 输入样例3：

```
void test()
{
    int i
    double A[10];
    for (i=0; i<10; i++) /**/
        A[i] = 0.1*i;
}
.

```

### 输出样例3：

```
YES
```

**鸣谢用户 王渊博 补充数据！**

### 参考代码

```C++
#include <bits/stdc++.h>
using namespace std;

int main(){
    // 提取括号序列
    string s;
    vector<string> seq;
    set<char> ch = {'(' , ')', '[', ']', '{', '}'};
    while(true) {
        getline(cin, s);
        if(s == ".") break;
        int n = s.size();
        for(int i = 0; i < n; i ++) {
            if(ch.find(s[i]) != ch.end()) {
                seq.push_back(string(1, s[i]));
            } else if(s[i] == '/' && i + 1 < n && s[i + 1] == '*') {
                i ++;
                seq.push_back("/*");
            } else if(s[i] == '*' && i + 1 < n && s[i + 1] == '/') {
                i ++;
                seq.push_back("*/");
            }
        }
    }
    // 判断
    stack<string> st;
    map<string, string> mp = {
        {"*/", "/*"},
        {")", "("},
        {"]", "["},
        {"}", "{"}
    };
    for(auto x : seq) {
        if(mp.count(x)) {
            if(st.empty()) {
                cout << "NO" << endl;
                cout << "?-" << x << endl;
                return 0;
            } else if(st.top() != mp[x]) {
                cout << "NO" << endl;
                cout << st.top() << "-?" << endl;
                return 0;
            } else st.pop();
        } else st.push(x);
    }
    if(st.size()) {
        cout << "NO" << endl;
        cout << st.top() << "-?" << endl;
    } else cout << "YES" << endl;
    return 0;
}
```

## 7-23 堆栈操作合法性

假设以`S`和`X`分别表示入栈和出栈操作。如果根据一个仅由`S`和`X`构成的序列，对一个空堆栈进行操作，相应操作均可行（如没有出现删除时栈空）且最后状态也是栈空，则称该序列是合法的堆栈操作序列。请编写程序，输入`S`和`X`序列，判断该序列是否合法。

### 输入格式:

输入第一行给出两个正整数N和M，其中N是待测序列的个数，M（$$\le 50$$）是堆栈的最大容量。随后N行，每行中给出一个仅由`S`和`X`构成的序列。序列保证不为空，且长度不超过100。

### 输出格式:

对每个序列，在一行中输出`YES`如果该序列是合法的堆栈操作序列，或`NO`如果不是。

### 输入样例：

```in
4 10
SSSXXSXXSX
SSSXXSXXS
SSSSSSSSSSXSSXXXXXXXXXXX
SSSXXSXXX
```

### 输出样例：

```out
YES
NO
NO
NO
```

### 参考代码

```C++
#include <bits/stdc++.h>
using namespace std;

int main(){
    int n, m, t = 0;
    string s;
    cin >> n >> m;
    while(n --) {
        cin >> s;
        t = 0;
        bool flag = true;
        for(char& c : s) {
            if(c == 'S') t ++;
            else t --;
            if(t < 0 || t > m) {
                flag = false;
                break;
            }
        }
        if(t) flag = false;
        cout << (flag ? "YES" : "NO") << endl;
    }
    
    return 0;
}
```

## 7-24 链表去重

给定一个带整数键值的链表 L，你需要把其中绝对值重复的键值结点删掉。即对每个键值 K，只有第一个绝对值等于 K 的结点被保留。同时，所有被删除的结点须被保存在另一个链表上。例如给定 L 为 21→-15→-15→-7→15，你需要输出去重后的链表 21→-15→-7，还有被删除的链表 -15→15。

### 输入格式：

输入在第一行给出 L 的第一个结点的地址和一个正整数 N（$$\le 10^5$$，为结点总数）。一个结点的地址是非负的 5 位整数，空地址 NULL 用 -1 来表示。

随后 N 行，每行按以下格式描述一个结点：

```
地址 键值 下一个结点
```

其中`地址`是该结点的地址，`键值`是绝对值不超过$$10^4$$的整数，`下一个结点`是下个结点的地址。

### 输出格式：

首先输出去重后的链表，然后输出被删除的链表。每个结点占一行，按输入的格式输出。

### 输入样例：

```in
00100 5
99999 -7 87654
23854 -15 00000
87654 15 -1
00000 -15 99999
00100 21 23854
```

### 输出样例：

```out
00100 21 23854
23854 -15 99999
99999 -7 -1
00000 -15 87654
87654 15 -1
```

### 参考代码

```C++
#include <bits/stdc++.h>
using namespace std;

int main(){
    int bg, n;
    unordered_map<int, int> mp, kv;
    cin >> bg >> n;
    int addr, val, nxt;
    while(n --) {
        cin >> addr >> val >> nxt;
        mp[addr] = nxt;
        kv[addr] = val;
    }
    vector<array<int, 3>> ans1, ans2;
    set<int> st;
    addr = bg;
    while(addr != -1) {
        if(st.find(abs(kv[addr])) == st.end()) {
            ans1.push_back({addr, kv[addr], mp[addr]});
            st.insert(abs(kv[addr]));
        } else {
            ans2.push_back({addr, kv[addr], mp[addr]});
        }
        addr = mp[addr];
    }
    int len = ans1.size(); 
    for(int i = 0; i < len; i ++) {
        printf("%05d %d ", ans1[i][0], ans1[i][1]);
        if(i + 1 >= len) cout << "-1" << endl;
        else printf("%05d\n", ans1[i + 1][0]);
    }
    len = ans2.size(); 
    for(int i = 0; i < len; i ++) {
        printf("%05d %d ", ans2[i][0], ans2[i][1]);
        if(i + 1 >= len) cout << "-1" << endl;
        else printf("%05d\n", ans2[i + 1][0]);
    }
    return 0;
}
```

## 7-21 装箱问题

假设有$$N$$项物品，大小分别为$$s_1$$、$$s_2$$、…、$$s_i$$、…、$$s_N$$，其中$$s_i$$为满足$$1\le  s_i \le 100$$的整数。要把这些物品装入到容量为100的一批箱子（序号1-$$N$$）中。装箱方法是：对每项物品, 顺序扫描箱子，把该物品放入足以能够容下它的第一个箱子中。请写一个程序模拟这种装箱过程，并输出每个物品所在的箱子序号，以及放置全部物品所需的箱子数目。

### 输入格式：

输入第一行给出物品个数$$N$$（$$\le 1000$$）；第二行给出$$N$$个正整数$$s_i$$（$$1 \le s_i \le 100$$，表示第$$i$$项物品的大小）。

### 输出格式：

按照输入顺序输出每个物品的大小及其所在的箱子序号，每个物品占1行，最后一行输出所需的箱子数目。

### 输入样例：

```in
8
60 70 80 90 30 40 10 20
```

### 输出样例：

```out
60 1
70 2
80 3
90 4
30 1
40 5
10 1
20 2
5
```

### 参考代码

```C++
#include <bits/stdc++.h>
using namespace std;

int main(){
    int n, m, t;
    cin >> n;
    vector<int> a(n, 100);
    for(int i = 0; i < n; i ++) {
        cin >> t;
        for(int j = 0; j < n; j ++) {
            if(a[j] >= t) {
                cout << t << " " << j + 1 << endl;
                a[j] -= t;
                break;
            }
        }
    }
    int u;
    for(u = 0; u < n; u ++) {
        if(a[u] == 100) break;
    }
    cout << u << endl;
    return 0;
}
```

## 7-25 愿天下有情人都是失散多年的兄妹

呵呵。大家都知道五服以内不得通婚，即两个人最近的共同祖先如果在五代以内（即本人、父母、祖父母、曾祖父母、高祖父母）则不可通婚。本题就请你帮助一对有情人判断一下，他们究竟是否可以成婚？

### 输入格式：

输入第一行给出一个正整数`N`（2 $$\le$$ `N` $$\le 10^4$$），随后`N`行，每行按以下格式给出一个人的信息：

```
本人ID 性别 父亲ID 母亲ID
```

其中`ID`是5位数字，每人不同；性别`M`代表男性、`F`代表女性。如果某人的父亲或母亲已经不可考，则相应的`ID`位置上标记为`-1`。

接下来给出一个正整数`K`，随后`K`行，每行给出一对有情人的`ID`，其间以空格分隔。

注意：题目保证两个人是同辈，每人只有一个性别，并且血缘关系网中没有乱伦或隔辈成婚的情况。

### 输出格式：

对每一对有情人，判断他们的关系是否可以通婚：如果两人是同性，输出`Never Mind`；如果是异性并且关系出了五服，输出`Yes`；如果异性关系未出五服，输出`No`。

### 输入样例：

```in
24
00001 M 01111 -1
00002 F 02222 03333
00003 M 02222 03333
00004 F 04444 03333
00005 M 04444 05555
00006 F 04444 05555
00007 F 06666 07777
00008 M 06666 07777
00009 M 00001 00002
00010 M 00003 00006
00011 F 00005 00007
00012 F 00008 08888
00013 F 00009 00011
00014 M 00010 09999
00015 M 00010 09999
00016 M 10000 00012
00017 F -1 00012
00018 F 11000 00013
00019 F 11100 00018
00020 F 00015 11110
00021 M 11100 00020
00022 M 00016 -1
00023 M 10012 00017
00024 M 00022 10013
9
00021 00024
00019 00024
00011 00012
00022 00018
00001 00004
00013 00016
00017 00015
00019 00021
00010 00011
```

### 输出样例：

```out
Never Mind
Yes
Never Mind
No
Yes
No
Yes
No
No
```

**鸣谢用户 徐校波 修正数据！**

### 参考代码

```C++
#include <bits/stdc++.h>
using namespace std;
using pii = pair<int, int>;

int main(){
    int n, m;
    cin >> n;
    unordered_map<int, char> gender;
    unordered_map<int, pii> prv;
    for(int i = 0; i < n; i ++) {
        int x, y, z;
        char c;
        cin >> x >> c >> y >> z;
        gender[x] = c;
        gender[y] = 'M', gender[z] = 'F';
        prv[x] = {y, z};
    }
    unordered_map<int, bool> book;
    bool flag = false;
    function<void(int, int)> dfs = [&](int x, int l) {
        if(l > 5 || flag) return ;
        if(book[x]) flag = true;
        if(!prv.count(x)) {
            if(x != -1) book[x] = true;
            return ;
        }
        auto [fa, mo] = prv[x];
        book[x] = true;
        dfs(fa, l + 1);
        dfs(mo, l + 1);
    };
    cin >> m;
    while(m --){
        int p1, p2;
        cin >> p1 >> p2;
        if(gender[p1] == gender[p2]) {
            cout << "Never Mind" << endl;
            continue;
        }
        flag = false;
        book.clear();
        dfs(p1, 1);
        dfs(p2, 1);
        if(flag) cout << "No" << endl;
        else cout << "Yes" << endl;
    }
    return 0;
}
```

## 7-26 深入虎穴

著名的王牌间谍 007 需要执行一次任务，获取敌方的机密情报。已知情报藏在一个地下迷宫里，迷宫只有一个入口，里面有很多条通路，每条路通向一扇门。每一扇门背后或者是一个房间，或者又有很多条路，同样是每条路通向一扇门…… 他的手里有一张表格，是其他间谍帮他收集到的情报，他们记下了每扇门的编号，以及这扇门背后的每一条通路所到达的门的编号。007 发现不存在两条路通向同一扇门。

内线告诉他，情报就藏在迷宫的最深处。但是这个迷宫太大了，他需要你的帮助 —— 请编程帮他找出距离入口最远的那扇门。

### 输入格式：

输入首先在一行中给出正整数 $$N$$（$$< 10^5$$），是门的数量。最后 $$N$$ 行，第 $$i$$ 行（$$1\le i \le N$$）按以下格式描述编号为 $$i$$ 的那扇门背后能通向的门：

```
K D[1] D[2] ... D[K]
```

其中 `K` 是通道的数量，其后是每扇门的编号。

### 输出格式：

在一行中输出距离入口最远的那扇门的编号。题目保证这样的结果是唯一的。

### 输入样例：

```in
13
3 2 3 4
2 5 6
1 7
1 8
1 9
0
2 11 10
1 13
0
0
1 12
0
0
```

### 输出样例：

```out
12
```

### 参考代码

```C++
#include <bits/stdc++.h>
using namespace std;

int main(){
    int n;
    cin >> n;
    vector<vector<int>> mp(n + 1);
    vector<bool> bk(n+1, 0);
    for(int i = 1; i <= n; i ++) {
        int k, t;
        cin >> k;
        while(k --) {
            cin >> t;
            mp[i].push_back(t);
            bk[t] = true;
        }
    }
    int ent = -1;
    for(int i = 1; i <= n; i ++) {
        if(!bk[i]) ent = i;
        bk[i] = false;
    }
    // bfs
    queue<int> q;
    q.push(ent);
    bk[ent] = true;
    int ans = -1;
    while(!q.empty()) {
        int f = q.front();
        q.pop();
        ans = f;
        for(int x : mp[f]) {
            if(!bk[x]) q.push(x);
        }
    }
    cout << ans << endl;
    return 0;
}
```

## 7-27 样本方差

![u=3226723262,278720713&fm=15&gp=0.jpg](C:\Users\Yipeng\Programming\ProfessionalBasicAptitudeTest\Practice\~\f9228bf8-d573-4621-a2f9-b2c8c9d480a4.jpg)

作为概率论随便考$$100$$分的你，口算出给定样本的方差自然也不在话下，不过今天需要你编程实现这样的程序。

样本方差：$$S^{2}=\frac{1}{n-1} \sum_{i=1}^{n}(X_{i}-\bar{X})^{2}$$

样本均值：$$\bar{X}=\frac{1}{n}\sum_{i=1}^{n}X_i$$

### 输入格式:

输入共两行。

第一行为一个正整数$$n, (2 \leq n \leq 10000)$$，即给定样本的数量。

第二行为$$n$$个整数，为每个样本的值。

### 输出格式:

输出仅 $$1$$ 行，为计算出来的样本方差（保留 $$2$$ 位小数，不足用 $$0$$ 补齐）。

### 输入样例:


```in
4
974 559 974 233
```

### 输出样例:

```out
129074.00
```

### 参考代码

```C++
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

int main(){
    int n;
    cin >> n;
    vector<int> a(n);
    ll sum = 0;
    for(int i = 0; i < n; i ++) {
        cin >> a[i];
        sum += a[i];
    }
    double aver = (double)sum / n;
    double s2 = 0;
    for(int i = 0; i < n; i ++) {
        s2 += (aver - a[i]) * (aver - a[i]);
    }
    s2 /= (n - 1);
    printf("%.2lf\n", s2);
    return 0;
}
```

##  打印字符菱形

根据输入的正整数$$n$$（$$1 \leq n \leq 9$$）和字符$$ch$$，按照如样例所示的格式打印出$$n$$行由字符$$ch$$构成的字符菱形。注意每个字符后没有空格。

### 输入格式:

输入在一行中给出正整数$$n$$（$$1 \leq n \leq 9$$）和字符$$ch$$。

### 输出格式:

打印出$$n$$行由字符$$ch$$构成的字符菱形。

### 输入样例:

```in
5 $
```

### 输出样例:

```out
  $
 $$$
$$$$$
 $$$
  $
```

### 参考代码

```C++
#include <bits/stdc++.h>
using namespace std;

int main(){
    int n; char c;
    cin >> n >> c;
    for(int i = 0; i < n; i ++) {
        for(int j = 0; j < abs(i - n / 2); j ++) cout << " ";
        for(int j = 0; j < (-abs(i - n / 2) + n / 2) * 2 + 1; j ++) cout << c;
        cout << endl;
    }
    return 0;
}
```











