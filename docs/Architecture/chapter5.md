Chapter 5 ILP - 2
nBranch Target Buffers 分支目标缓冲 *

nConcept and Advantages of Dynamic Scheduling * 动态调度

qScoreboard  记分牌
qTomasulo
qSpeculation 前瞻执行
qTomasulo with ReOrder Buffer 再定序缓冲
nSuperscalar and VLIW * 超标量与超长指令字   

什么是动态调度？动态调度的好处？
动态是相对静态而言的，静态是指通过编译器（软件）进行调度，也就是在运行前进行调度，不可更改，动态调度是通过硬件实现在指令执行过程中的调度，同时还能保证data flow和exception behavior。

优点：

可以handle 静态调度时编译器检测不出来的相关（dependence），比如cache miss（软件方法检测不出来），在等调进cache的时候硬件调度可以使得处理器去执行别的指令。
一条指令的不同阶段可以在不同流水线中完成（尽管编译的时候他们是在同一条流水线中的）
 关键思想：允许被stall的指令停顿期间执行后面的指令（顺序发射，乱序执行，乱序完成）

   DIVD  F0,F2,F4
   ADDD  F10,F0,F8
  SUBD  F12,F8,F14

比如：DIVD和ADDD之间有RAW，因此ADDD被stall，此时SUBD和两者不存在任何相关和冲突，因此硬件可以在ADDD的stall期间执行SUBD

具体实现：将ID段拆成两个：Issure 和 Read operands，前者检测结构冲突，只要没有SH，该指令就能发射；后者检测数据冲突，等到没有DH就可以读操作数



但是，这种方式可能会带来WAR和WAW冲突：

 DIVD  F10,F0,F2
   ADDD  F10,F4,F6
  SUBD  F6,F8,F14

如果不对ADDD和SUBD使用寄存器重命名，那么因为SUBD和ADDD存在反相关（F6）如果流水线在ADDD读出F6之前就能完成SUBD，就回出现错误。类似的，DIVD和SDDD存在输出相关，流水线必须能检测出该相关，并避免WAW冲突。（可以用寄存器重命名解决）

记分牌算法（scoreboard）
记分牌通过记录指令执行过程中指令的状态，运算部件的状态，寄存器的状态实现集中控制（centralized control），其中记分牌只记录四种指令状态：



记录的三种状态各自有一个表：如下所示

指令状态表特点：四个段 ：发射 读取 执行 写回
功能部件状态表特点： 1+2+2+2
寄存器状态表特点：对应功能部件（一对一？）


下图显示了第二条LD指令准备写结果之前的三表状态：

指令状态表：

此时LD2 处于EX阶段，由于MUL SUB 与LD2有数据相关（F2，RAW）所以两者都只能过issue（无结构冲突）不能进入Read。
由于MUL和DIV有数据相关（F0，RAW）所以DIV同理也只能在Issue阶段。
ADD与SUB有结构冲突（争用加法器）所以连发射都不行。
功能单元状态表：

Fi 目的寄存器 Fj Fk 源寄存器 Qj Qk 源寄存器的来源（来自哪个功能部件） Rj Rk （yes表示就绪待取，no表示取完或者未就绪）

Integer的Rj表示取完。
Mult1的Rj表示没就绪，Rk表示就绪待取
寄存器状态表：

表示存到F0寄存器的结果来自功能部件Mult1




下图显示了MULT指令准备写结果之前的状态：

由于SUB和MUL不存在任何冲突和相关，且SUB 2cycles，MUL 10cycles 因此当MUL到了EX段，SUB一定执行完了
MUL和DIV有RAW（F0），所以MUL没吧结果写到F0之前DIV只能处于Issue
DIV和ADD有WAR（F6），所以DIV没读F6之前ADD必须阻塞在EX段


下图显示了DIV指令准备写结果之前的状态：

DIV写结果前，前面的指令一定都完成了
DIV要40个周期，ADD只要两个，因此当DIV取走F6后ADD立刻执行完全有足够的时间赶在DIV前面完成。


总结： 



 

Tomasulo算法
主要思想：

将保留站作为虚拟寄存器存储 指令和操作数，实现分布式控制和缓存
记录和检测指令相关，功能单元直接从保留站获得操作数（不再从寄存器读），操作数一旦就绪就立即执行，减少RAW(因为读操作的源已被定向（预约）到写的指令,只有操作数就绪时读才执行)；
通过寄存器换名来消除WAR冲突和WAW冲突。寄存器换名是通过保留站和流出逻辑来共同完成的。(之后的写操作对保留站中的指令不再有影响,因为已换名,也就是指令中寄存器号换成了产生这个操作数的保留站标识，操作数可从CDB得到,不用再从寄存器读)
记分牌和tomasulo比较：


 可见：

tomasulo的控制和缓存分布在各保留站中 而 记分牌中控制和缓存集中在记分牌
使用功能单元对操作数进行计算不再是从寄存器取数（记分牌），而是从保留站的操作数缓存中取数（因此减少RAW，从寄存器读可能遇到重名的寄存器导致RAW）
寄存器换名
优点：

冲突检测逻辑是分布的（通过保留站和CDB实现）
消除了WAR和WAW冲突 
缺点：

实现复杂
需要大量的高速相联存储
性能受CDB影响大（解决：多CDB）


例题：
下面是采用DLX浮点部件的Tomasulo算法执行过程中用到的状态表，试填写状态表中的相关空白。 假定：浮点流水线的延迟如下：加法2个时钟周期，乘法10个时钟周期，除法40个时钟周期。给出SUBD 将要写结果时状态表的信息。只填写相关部分空格。

 

 

指令

指令状态表

IS

    EX
    
    WR

LD F6,34(R2)

√

√

√

LD F2,45(R3)

√

√

√

MULTD FO,F2,F4

√

 

 

SUBD F8,F6,F2

√

√

 

DIVD F10,F0,F6

√

 

 

ADDD F6,F8,F2

√

√

 

部件

名称

                      保留站

Busy

Op

Vj

Vk

Qj

Qk

A

Load1

no

 

 

 

 

 

 

Load2

no

 

 

 

 

 

 

Add1

yes

SUBD

Mem[45+Regs[R3]]

Mem[34+Regs[R2]]

 

 

 

Add2

yes

ADDD

 

Mem[45+Regs[R3]]

Add1

 

 

Add3

no

 

 

 

 

 

 

Mult1

yes

MULTD

Mem[45+Regs[R3]]

Regs[4]

 

 

 

Mult2

yes

DIVD

 

Mem[34+Regs[R2]]

Mult1

 

 

 

结果寄存器状态表

F0

F2

F4

F6

F8

F10

……

F30

部件名称

 Mult1

 

 

Add2

 Add1

 Mult2

……

 

 

 

前瞻技术(speculation)
前瞻：循序处理器还未判断指令是否能执行之前就提前执行，以克服控制相关。他的实质是数据流执行：只要操作数就绪，指令就执行。

与流水线中的静态分支预测区别：前瞻技术是依靠硬件+动态分支预测技术+动态调度实现的。



带有前瞻的tomasulo
前瞻是为了让动态调度算法更好地处理分支指令（有控制相关）。tomasulo的指令完成和写结果都在WR段，而在前瞻执行中加以区分，分成两个不同的段：写结果，指令确认，特点是：允许指令乱序执行，但是必须顺序确认（注意不是顺序完成，确认是顺序的，但是完成可以乱序）。

写结果段：前瞻执行的结果写到ROB，并通过CDB传递ROB中的结果到需要他们的指令保留站。

指令确认段：在分支结果出来后，对相应的前瞻执行结果予以确认，如果前瞻是对的，就把ROB中的结果写到寄存器或者存储器，如果是错的，就不予以确认并从那条分支指令的另一条路径重新开始执行。

ROB的每一项：

指令类型（指出该指令是分支指令、store指令或寄存器操作指令）+目标地址（ 给出指令执行结果应写入的目标寄存器号（如果是 load和ALU指令）或存储器单元的地址（如果是store指令））+ 数据值字段（用来保存指令前瞻执行的结果，直到指令得到确认）+就绪字段（ 指出指令是否已经完成执行并且数据已就绪）+控制字段（设置ROB的某一项是否被占用）

普通tomasulo和带有前瞻的tomasulo对比：



 

 

超标量和超长指令字
前面的方法可以提高并行度,但是CPI不可能低于1(最多就是1),想要在一个周期流出(发射)多条指令就得用多指令流出技术,包括超标量和超长指令字两种方法.

超标量和超长指令字都是指具有每个周期多指令流出能力的计算机。他们的区别在于调度方式（动态or静态）。.

静态调度超标量(顺序执行)
通过编译器进行调度+流出指令时用单独硬件检测冲突 == 静态调度+动态流出（所谓动态流出是指流出包中的指令可能不会全部流出，比如某指令与其他存在冲突，就只流出该指令之前的指令）

MIPS中的静态超标量实例:

这里是2-流出超标量，每个时钟周期流出1条整型指令和1条浮点指令（load store 分支看做整型）

优点：和任意2-流出相比，对硬件要求低（比如1整+1整，就需要两套整型的硬件）
缺点1：把load归为整型，如果load是浮点load，可能会和浮点操作并行流出导致浮点寄存器访问冲突
缺点2：load有一个时钟延迟，这使得使用load的结果的指令必须和load相隔至少一个周期（在有定向的情况下），因此load之后的三条指令都不能用其结果


超标量中的循环展开：

需要考虑的问题：LD和ADD之间要有一个时钟的延迟，ADD和SD之间要有两个时钟的延迟

那么如果只展开四次ADD和SD的延迟不可避免，解决方法是进行更多的展开（5次）





动态调度超标量(乱序执行)
通过硬件进行调度+两个tomasulo控制器（整型和浮点，确保不会乱序流出）== 动态调度+动态流出



超长指令字
完全靠编译器进行调度 == 静态调度+静态流出（所谓静态流出是指每个时钟周期流出的指令数是固定的，这些指令构成一个长指令或指令包）

优点：对硬件依赖低，并行性完全由编译器挖掘。
缺点1：同一个指令包中的指令必须保证是不相关的。
缺点2：需要优秀的编译技术实现跨分支调度。
缺点3：没有冲突检测硬件，而是采用锁步机制（lockstep），某部件停顿整个处理机就停顿。
缺点4：操作槽不应定能被填满+为了提高并行性进行了过多循环展开，造成指令长度增加。
缺点5：机器代码不兼容。


VLIW中的循环展开（指令包长度=2+2+1，注意其中某个指令槽不一定会被填满）：

9 clocks/ 7 iterations = 1.3clock_per_interation



超标量和VILW比较（硬件和软件比较）


总结：

硬件的分支预测能力好，所需的代码少，但是需要大量的硬件

软件的推断设计简单，所需硬件少，但是代码量大
————————————————
版权声明：本文为CSDN博主「ASR_THU」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/zongza/article/details/83933327