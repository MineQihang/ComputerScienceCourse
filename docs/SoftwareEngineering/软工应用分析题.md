前面的结构化分析和面向对象分析建模看实验指导书和UML的PPT即可。这个文件请重点参考后面两种测试中涉及的方法。

# 一、结构化分析

## 1. 数据流图【重要】

参考PPT和实验文档即可。

##  2. 数据字典【重要】

参考PPT和实验文档即可。

## 3. 控制流建模

不重要。考到就看PPT。



# 二、面向对象分析

## 1. 用例图【重要】

**请参考UML的PPT。**

分析用例实现中，对象之间的交互行为，核心是时序图、状态图等

【用例建模】

· 用例表示从执行者的角度观察到系统的功能和外部行为。

· 用例图主要描述用户需求，强调谁在使用系统，系统可以实现哪些功能目标。

· 用例特征

· 用例都是动宾结构

· 用例是相互独立的

· 用例由参与者启动

· 有可观测的执行结果

【识别用例】

识别用例最好的方法就是从分析系统的参与者（可以是角色、外部系统、设备甚至时钟信号等）开始，考虑每一个参与者是如何使用系统的。

**【用例图】**

用例模型主要包含4种元素：执行者、用例，执行者与用例间关联、用例间关系。

【用例间关系】

《include》关系

父用例执行过程中会用到子用例(无条件执行)。

子用例一般表示为公共功能。

![img](https://qihang-1306873228.cos.ap-chongqing.myqcloud.com/imgs/clip_image008.jpg)

《extend》关系

父用例在特定情况下（称为扩展点）会用到子用例(有条件执行)

子用例一般表示为异常功能。

![img](https://qihang-1306873228.cos.ap-chongqing.myqcloud.com/imgs/clip_image010.jpg)

泛化(generalization)关系

当多个用例共同拥有一种类似的行为时，可以将它们的共性抽象成为父用例，其他用例作为子用例。

该关系也可存在于参与者之间。

![img](https://qihang-1306873228.cos.ap-chongqing.myqcloud.com/imgs/clip_image012.jpg)

![img](https://qihang-1306873228.cos.ap-chongqing.myqcloud.com/imgs/clip_image014.jpg)

【用例描述】

单纯的用例图并不能描述完整的信息，需要用文字描述不能反映在图形上的信息。

用例描述是将用例发生的各种场景描述出来，表示参与者与系统交互时双方的行为，即参与者做什么，系统做什么反应。

场景能真实反映参与者在用例执行中可能遇到的

各种情形。

 可以使用**用例模版**或**活动图**描述用例执行中的各种场景。

【用例模板】

用例描述模版的内容大致包括：用例名、参与者，前置条件，后置条件，事件流等。

用例的事件流

说明参与者与系统之间的交互过程；

说明用例在不同条件下可以选择执行的多种方案；

分为基本流和备选流两类

基本流：描述该用例正常执行的一种场景，系统执行一系列活动步骤来响应参与者提出的服务请求；

备选流：描述用例执行过程中异常的或偶尔发生的一些情况。

![img](https://qihang-1306873228.cos.ap-chongqing.myqcloud.com/imgs/clip_image016.jpg)





## 2. 类图【重要】

**请参考UML的PPT。**

【类图】

（具体画法参考实验文档）

目标是对领域内的概念类进行分析，并抽象出对应的类及其关系等。

具体包括三个步骤：

1. 从用例场景中寻找概念类

(1)    分析用例场景

(2)    找出其中的名词或名词短语作为分析类备选

(3)    如何判断分离出的词是否是分析类？

![img](https://qihang-1306873228.cos.ap-chongqing.myqcloud.com/imgs/clip_image026.jpg)

2. 细化概念类，识别其类型（如边界类、实体类等）

例子：学生选课用例

![img](https://qihang-1306873228.cos.ap-chongqing.myqcloud.com/imgs/clip_image028.jpg)

通过分析，可以确定以下分析类：

![img](https://qihang-1306873228.cos.ap-chongqing.myqcloud.com/imgs/clip_image030.jpg)

分析类是概念层次的东西，源于问题空间，与实现方式无关。

类的类型：

《Entity》 classes 表示系统中的持久信息或贯穿应用的数据封装

《Boundary》 classes 实现用户与系统的交互，如用户界面或外部接口

《Control》 classes 实现对用例行为的封装，管理、调度其它类

3. 为概念类定义属性及行为

属性描述了一个已被选择以包含在分析模型中的类。

要识别类所属行为，可以对处理叙述进行语法解析，看看动词；还可以结合动态（交互）建模，识别分析类的行为。

例子：

![img](https://qihang-1306873228.cos.ap-chongqing.myqcloud.com/imgs/clip_image032.jpg)

4. 定义关系

(1)    关联关系：关联关系可以使一个类可以引用另一个类的属性和方法。一般使用成员变量来实现。

![img](https://qihang-1306873228.cos.ap-chongqing.myqcloud.com/imgs/clip_image034.jpg)

(2)    聚合关系：表示整体和部分的关系，整体与部分可以分开,使用带空心菱形的实线来表示。

![img](https://qihang-1306873228.cos.ap-chongqing.myqcloud.com/imgs/clip_image036.jpg)

(3)    组合关系：也是整体与部分的关系，但是整体与部分不可以分开,使用实心带菱形的实线来表示。组合关系中整体类和部分类必须有相同的生命周期。

![img](https://qihang-1306873228.cos.ap-chongqing.myqcloud.com/imgs/clip_image038.jpg)

(4)    依赖关系：即一个类的实现需要另一个类的协助。多数情况下，依赖关系表现在某个类的方法使用另一个类的对象作为参数。

![img](https://qihang-1306873228.cos.ap-chongqing.myqcloud.com/imgs/clip_image040.jpg)

(5)    泛化关系：表示类与类、接口与接口之间的继承关系

![img](https://qihang-1306873228.cos.ap-chongqing.myqcloud.com/imgs/clip_image042.jpg)

实例：

![img](https://qihang-1306873228.cos.ap-chongqing.myqcloud.com/imgs/clip_image044.jpg)



## 3. 时序图（顺序图）【重要】

**请参考UML的PPT。**

【时序图】

时序图建模步骤

 (1)对每个用例，建立系统时序图（可选）

 (2)建立对象时序图

 (3)从图中确定分析类的行为

主要步骤

按从左到右的顺序

1、列出启动该用例的参与者；

2、列出参与者使用的边界类；

3、列出管理该用例的控制类；

4、根据用例的执行流程，按时间顺序列出分析类之间的消息序列。

**例子：****还书用例**

1. 借阅者点击还书按钮向系统申请还书
2. 系统提示借阅者输入还书号等信息
3. 借阅者输入还书信息后，系统查询该书是否已超期。
4. 如果未超期，则记录用户还书信息并更新图书可借状态，并返回借阅者成功还书信息。
5. 如果已超期，则系统提示超期、罚款金额等信息。
6. 借阅者如果认可，并确认缴纳罚款，则系统执行扣款并还书，返回借阅者成功还书信息。

![img](https://qihang-1306873228.cos.ap-chongqing.myqcloud.com/imgs/clip_image052.jpg)

## 4. 状态图

请参考UML的PPT。

【状态图】

状态图描述了一个对象生命周期内所经历的状态序列，以及引起状态转移的外部事件。

状态图的主要作用：

描述多个状态之间的转换顺序，即事件的执行顺序，避免非法的事件序列。（如: 必须先付款进入“已付款”状态，才能执行发货进入“已发货”状态。）

![img](https://qihang-1306873228.cos.ap-chongqing.myqcloud.com/imgs/clip_image054.jpg)

![img](https://qihang-1306873228.cos.ap-chongqing.myqcloud.com/imgs/clip_image056.jpg)

## 5. 其他

### 5.1. 活动图

【活动图】

![img](https://qihang-1306873228.cos.ap-chongqing.myqcloud.com/imgs/clip_image018.jpg)

 

### 5.2. ER图

【ER图】

![img](https://qihang-1306873228.cos.ap-chongqing.myqcloud.com/imgs/clip_image022.jpg)

![img](https://qihang-1306873228.cos.ap-chongqing.myqcloud.com/imgs/clip_image024.jpg)

### 5.3. CRC模型

【CRC模型, Class-responsibility-collaborator】

作用：帮助补充、完善、优化分析类（属性、行为）

职责：职责是与类相关的属性和操作。

简单的说，职责就是“类所知道的或能做的任何事情”,可理解为类的能力。

例如，顾客有名字、地址和电话号码，这是顾客知道的东西。顾客要借书和还书，这是顾客要完成的事情。

分配职责的指导原则：属性和与之相关的行为应该在同一个类中。

类主要通过两种方式实现其职责：

通过自己内部的行为，实现特定的职责

请求其它类的协作

如果某个对象请求协作，就会向其它对象发送消息。

消息接收者作为服务方，通过自己的服务作为对消息发送者的回应。

职责是一种较高层次的抽象，其在设计过程中可能细化为一到多个具体的行为。

例子：用户登录用例中，登录控制类的职责之一是“身份验证” 。该职责在设计阶段，可以被细化为多个具体方法：getUser()，getRole()，getGroup()，check()

![img](https://qihang-1306873228.cos.ap-chongqing.myqcloud.com/imgs/clip_image046.jpg)



### 5.4. 包图

【包图】

对于较大的项目，由于有很多的类和用例，常常会使系统结构看起非常复杂。

通过包图，庞大系统之间的关系变得更简单，整个系统的架构一目了然。

原则：将概念上或语义上相近的类纳入一个包

包之间的主要关系是依赖关系。

意味着两个Package内的元素之间存在着一个或多个依赖

![img](https://qihang-1306873228.cos.ap-chongqing.myqcloud.com/imgs/clip_image048.jpg)

![img](https://qihang-1306873228.cos.ap-chongqing.myqcloud.com/imgs/clip_image050.jpg)















# 三、白盒测试

## 1. 基本路径测试法【重要】

参考视频：https://www.bilibili.com/video/BV13V4y1g7tc/?share_source=copy_web&vd_source=7ba452d8ee6f8b8a4b8ef831bf573bda

步骤：

- **(1) 画出控制流图**

  流程图用来描述程序控制结构。可将流程图映射到一个相应的流图（假设流程图的菱形决定框中不包含复合条件）。

  - 在流图中，每一个圆，称为流图的**结点**，代表一个或多个语句。一个处理方框序列和一个菱形决策框可被映射为一个结点 。
  - 流图中的箭头，称为**边或连接**， 代表控制流 ， 类似于流程图中的箭头 。一条边必须终止于一个结点 ， 即使该结点并不代表任何语句（例如：if-else-then结构）。
  - 由边和结点限定的范围称为**区域** 。

  控制流图基本结构：

  <img src="https://qihang-1306873228.cos.ap-chongqing.myqcloud.com/imgs/image-20230216193457766.png" alt="image-20230216193457766" style="zoom: 67%;" />

  在将程序流程图简化成控制流图时 ， 应注意 ：

  - 在选择或多分支结构中 ， 分支的**汇聚处应有一个汇聚结点**；
  - 边和结点圈定的区域叫做区域 ， 当对区域计数时 ， **图形外的区域也应记为一个区域**。

  >  例子：
  >
  > <img src="https://qihang-1306873228.cos.ap-chongqing.myqcloud.com/imgs/image-20230216193707594.png" alt="image-20230216193707594" style="zoom: 67%;" />

  如果遇到一个条件表达式有多个逻辑运算符，则需改为一系列只有单条件的嵌套的判断：

  <img src="https://qihang-1306873228.cos.ap-chongqing.myqcloud.com/imgs/image-20230216193952143.png" alt="image-20230216193952143" style="zoom:67%;" />

  > 例子：
  >
  > <img src="https://qihang-1306873228.cos.ap-chongqing.myqcloud.com/imgs/image-20230216195215976.png" alt="image-20230216195215976" style="zoom:67%;" />
  >
  > <img src="https://qihang-1306873228.cos.ap-chongqing.myqcloud.com/imgs/image-20230216195401697.png" alt="image-20230216195401697" style="zoom:67%;" />

- **(2)计算环路复杂度（圈复杂度或McCabe复杂度）**

  圈复杂度是一种为程序逻辑复杂性提供定量测度的软件度量， 将该度量用于计算程序的基本的独立路径数目 ，为确保所有语句至少执行一次的测试数量的上界。独立路径必须包含一条在定义之前不曾用到的边。
  有以下三种方法计算圈复杂度：

  - 流图中区域的数量对应于环型的复杂性；
  - 给定流图$G$的圈复杂度$V(G)$， 定义为$V(G) = E - N  + 2$，$E$是流图中边的数量，$N$是流图中结点的数量；
  - 给定流图 G 的圈复杂度$V(G)$， 定义为$V(G) = P + 1$， P 是流图$G$中判定结点的数量。

  > 例子（接上）：
  >
  > <img src="https://qihang-1306873228.cos.ap-chongqing.myqcloud.com/imgs/image-20230216195752314.png" alt="image-20230216195752314" style="zoom:67%;" />

- **确定独立路径**

  一条独立路径是指与其他的独立路径相比，至少引入一个新处理语句或一个新判断的程序通路。**$V(G)$值正好等于该程序的独立路径的条数。**

  > 例子（接上）：
  >
  > 根据上面的计算方法，可得出四条独立的路径。
  > 路径1： 4 一 14
  > 路径2： 4 一 6 一 7 一 14
  > 路径3： 4 一 6 一 8 一 10 一 13 一 4 一 14
  > 路径4： 4 一 6 一 8 一 11 一 13 一 4 一 14
  > 根据上而的独立路径 ， 去设计输入数据 ， 使程序分别执行到上面四条路径 。

- **准备测试用例**

  为了确保基本路径集中的每一条路径的执行，根据判断结点给出的条件，选择适当的数据以保证某一条路径可以被测试到。

  > 例子（接上）：
  >
  > 满足上面例子基本路径集的测试用例是 ：
  >
  > <img src="https://qihang-1306873228.cos.ap-chongqing.myqcloud.com/imgs/image-20230216200329566.png" alt="image-20230216200329566" style="zoom:67%;" />

### 实例1

**题目**：判断任意年份是否为闰年，需要满足以下条件中的任意一个：

- 该年份能被4整除同时不能被100整除；
- 该年份能被400整除。

代码如下：

```c
int isLeap (int year) {
    if(year % 4 == 0) {             // 1
        if(year % 100 == 0) {       // 3
            if(year % 400 == 0) {   // 4
                leap = 1;           // 6
            } else {
                leap = 0;           // 7
            }
        } else {
            leap = 1;               // 5
        }
    } else {
        leap = 0;                   // 2
    }
    return leap;                    // 8
}
```

请采用基本路径测试法设计上述程序的测试用例。要求：  

（1）画出流图；

（2）计算环路复杂度；

（3）给出基本路径； 

（4）给出满足基本路径测试标准的最小测试用例集。（提示：测试用例= 测试输入+预期输出。）

**解答**：

（1）画出流图

<img src="https://qihang-1306873228.cos.ap-chongqing.myqcloud.com/imgs/image-20230216201610301.png" alt="image-20230216201610301" style="zoom: 40%;" />

（2）计算环路复杂度

（方法一）一共有4个区域，因此$V(G)=4$。

（方法二）一共有8个节点，10条边，因此$V(G) = E - N  + 2=10-8+2=4$。

（方法三）一共有三个判定节点：1、3、4，因此$V(G) = 3 + 1 = 4$。

（3）写出基本路径

路径1：1-2-8

路径2：1-3-5-8

路径3：1-3-4-6-8

路径4：1-3-4-7-8

（4）给出满足基本路径测试标准的最小测试用例集

| 覆盖路径 | 测试输入   | 测试输出 | 说明                            |
| -------- | ---------- | -------- | ------------------------------- |
| 1        | year = 1   | 0        | 不能被4整除                     |
| 2        | year = 4   | 1        | 能被4整除，但不能被100整除      |
| 3        | year = 400 | 1        | 能被4，100，400整除             |
| 4        | year = 200 | 0        | 能被4，100整除，但不能被400整除 |



### 实例2

**题目**： 请采用基本路径测试法设计下列伪码程序的测试用例。  要求：  

（1）画出流图；

（2）计算环路复杂度；

（3）给出基本路径； 

（4）给出满足基本路径测试标准的最小测试用例集。（提示：测试用例= 测试输入+预期输出。）

```
1: Start Input(a,b,c,d) 
2:	If(a>0) 
3:		and (b>0) 
4:			Then x=a+b 
5: 		Else x=a-b 
6:	End if 
7:	If (c>a) 
8:		or (d<b) 
9:			Then y=c-d 
10:		Else y=c+d 
11:	End if 
12: Print(x,y) Stop 
```

**解答**：（1）画出流图

<img src="https://qihang-1306873228.cos.ap-chongqing.myqcloud.com/imgs/image-20230216203606429.png" alt="image-20230216203606429" style="zoom:40%;" />

（2）计算环路复杂度

（方法一）一共有5个区域，因此$V(G)=5$。

（方法二）一共有12个节点，15条边，因此$V(G) = E - N  + 2=15-12+2=5$。

（方法三）一共有三个判定节点：2、3、7、8，因此$V(G) = 4 + 1 = 5$。

（3）写出基本路径

路径1：1-2-5-6-7-9-11-12

路径2：1-2-3-5-6-7-9-11-12

路径3：1-2-3-4-6-7-9-11-12

路径4：1-2-5-6-7-8-9-11-12

路径4：1-2-5-6-7-8-10-11-12

（4）给出满足基本路径测试标准的最小测试用例集

| 覆盖路径 | 测试输入(a,b,c,d) | 测试输出(x,y) | 说明                       |
| -------- | ----------------- | ------------- | -------------------------- |
| 1        | (0, 0, 1, 0)      | (0, 1)        | a <= 0 && c > a            |
| 2        | (1, 0, 2, 0)      | (1, 2)        | a > 0 && b <= 0 && c > a   |
| 3        | (1, 1, 2, 0)      | (2, 2)        | a > 0 && b > 0 && c > a    |
| 4        | (0, 0, 0, -1)     | (0, 1)        | a <= 0 && c <= a && d < b  |
| 5        | (0, 0, 0, 0)      | (0, 0)        | a <= 0 && c <= a && d >= b |



## 2. 控制结构测试法(逻辑覆盖法)

参考视频：https://www.bilibili.com/video/BV1zL4y1A785

以下面这个代码来解释：

```
if A and B
	then action1
if C or D
	then action2
```

- **语句覆盖**：语句至少被执行一次

  要让`action1`和`action2`被走过。

  `action1`: `A and B = T` => `A = T, B = T`；

  `action2`: `C or D = T` => `C = T`。

  因此设计测试用例为：`A = T, B = T, C = T`。

- **判定覆盖**：判定至少真假一次

  if后的所有就是判定，比如上述的`A and B`和`C or D`。

  ```
  A and B = T => A = T, B = T  // (1)
  A and B = F => A = T, B = F  // (2)
  C or  D = T => C = T, D = F  // (3)
  C or  D = F => C = F, D = F  // (4)
  ```

  设计测试样例为

  ```
  test1: A = T, B = T, C = T, D = F // (1) & (3)
  test2: A = T, B = F, C = F, D = F // (2) & (4)
  ```

- **条件覆盖**：条件至少真假一次

  判定中的条件，比如上述的`A`、`B`、`C`、`D`。

  ```
    (5)  (6)
  A  T    F
  B  T    F
  C  T    F
  D  T    F
  ```

  设计测试样例为

  ```
  test1: A = T, B = T, C = T, D = T // (5)
  test2: A = F, B = F, C = F, D = F // (6)
  ```

- **判定条件覆盖**

  就是要同时覆盖`(1)~(6)`。

  ```
  test1: A = T, B = T, C = T, D = T // (1) & (3) & (5)
  test2: A = F, B = F, C = F, D = F // (2) & (4) & (6)
  ```

- **组合覆盖**（条件组合覆盖）

  要让一个判定中的每个条件的各种组合至少一次。

  ```
         A B | C D
  test1: T T | T T
  test2: T F | T F
  test3: F T | F T
  test4: F F | F F
  ```

- **路径覆盖**

  <img src="https://qihang-1306873228.cos.ap-chongqing.myqcloud.com/imgs/image-20230216211808589.png" alt="image-20230216211808589" style="zoom: 67%;" />



# 四、黑盒测试

## 1.等价类划分

参考视频：https://www.bilibili.com/video/BV1MT411M7EC/?share_source=copy_web&vd_source=7ba452d8ee6f8b8a4b8ef831bf573bda

把被测对象的输入域划分为有限个等价区段“等价类”， 以有针对性的等价类少量测试，代替漫无边际的、数量较大的 “ 穷尽 ” 测试或随机测试。每个等价类的典型值的测试作用，可以代表这一类的所有其它数据。

等价类分为：

- 有效等价类：对于程序的规格说明是合理、有意义的输入数据的集合
- 无效等价类：对于程序的规格说明是不合理的、没有意义的输入数据的集合

步骤：

- **划分“等价类”**

  应按照输入条件（如输入值的范围、值的个数、 值的集合 、输入条件）划分为有效等价类和无效等价类。

  > 例1：每个学生可选修1-3门课程
  >
  > - 可以划分一个有效等价类：选修1-3门课程。
  > - 可以划分两个无效等价类：未选择选修课，选修课超过3门 。
  >
  > 例2：标识符的第一个字符必须是字母
  >
  > 可以划分为一个有效等价类：第一个字符是字母
  >
  > （或两个有效等价类：第一个字母是大写字母 / 小写字母） 。
  >
  > 可以划分一个无效等价类 ： 第一个字符不是字母 。

  等价法划分类的启发式规则：

  - 如果规定了输入值的范围 ， 则可划分出一个有效的等价类 （ 输入值在此范围内 ） 和两个无效的等价类 （ 输入值小于最小值或大于最大值 ） 。
  -  如果规定了输入数据的个数 ， 则类似地可以划分出一个有效的等价类和两个无效的等价类 。
  - 如果规定了输入数据的一组值 ， 而且程序对不同输入值做不同处理 ， 则每个允许的输入值是一个有效的等价类 ， 此外还有一个无效的等价类 （ 任意一个不允许的输入值 ） 。
  - 若规定了输入数据的规则 ， 则可以划分出一个有效的等价类 （ 符合规则 ） 和若干个无效的等价类 （ 从各种不同角度违反规则 ）
  - 若规定了输入数据为整型 ， 则可以划分出正整数 、 零和负整数等三个有效等价类 。
  -  若处理对象是表格 ， 则应该使用空表以及含一项或多项的表 。

- **选择测试用例**
  - 为每个等价类编号；
  - 使一个测试用例尽可能覆盖多个有效等价类；
  -  特别要注意的是：**一个测试用例只能覆盖一个无效等价类**；**每一个无效等价类都需要测试用例**。



### 实例1

**题目**：在某一 PASCAL 语言版本中规定：在同一说明语句中 ， 标识符至少必须有一个，标识符是由字母开头 、 后跟字母或数字的任意组合构成 。 有效字符数为 1 个 ，最大字符数为 80 个 。 并且规定：标识符必须先说明，再使用 。请使用等价划分法进行测试用例设计。

**解答**：为用等价类划分的方法得到上述规格说明所规定的要求 ， 本着前述的划分原则 ，建立等价类表 ， 如表所示 （ 表中括中的数为等价类编号 ） 。

<img src="https://qihang-1306873228.cos.ap-chongqing.myqcloud.com/imgs/image-20230216213348026.png" alt="image-20230216213348026" style="zoom: 80%;" />

下面选取了8个测试用例，它们覆盖了所有的等价类。

<img src="https://qihang-1306873228.cos.ap-chongqing.myqcloud.com/imgs/image-20230216213404448.png" alt="image-20230216213404448" style="zoom: 67%;" />



### 实例2

**题目**：下面以测试`NextDate`函数的具体实例为出发点 ， 讲解使用等价类划分法的细节 。 输入 3 个变量 （ 年 、 月 、 日 ） ， 函数返回输入日期后面一天的日期 ：1<=月<=12 ， 1 <=日<=31 ， 1812<=年<=2012 。 给出等价类划分表并设计测试用例 。
**解答**：**（1）划分等价类 ， 得到等价类划分表** ， 如下表所示 。

<img src="https://qihang-1306873228.cos.ap-chongqing.myqcloud.com/imgs/image-20230216213630798.png" alt="image-20230216213630798" style="zoom:67%;" />

（2）为**有效等价类**设计测试用例，如下表所示。

<img src="https://qihang-1306873228.cos.ap-chongqing.myqcloud.com/imgs/image-20230216213656379.png" alt="image-20230216213656379" style="zoom:67%;" />

（3）为**无效等价类**设计测试用例，如下表所示。

<img src="https://qihang-1306873228.cos.ap-chongqing.myqcloud.com/imgs/image-20230216213829919.png" alt="image-20230216213829919" style="zoom:67%;" />

<img src="https://qihang-1306873228.cos.ap-chongqing.myqcloud.com/imgs/image-20230216213851353.png" alt="image-20230216213851353" style="zoom:67%;" />



## 2. 边界值分析

经验表明，处理边界情况时程序最容易发生错误

**边界类型：下标 、 数据结构 、 循环 、 选择等的边界附近**

——使程序运行在边界附近的测试方案 ， 更容易暴露程序错误

通常选用**等价类边界值**作为边界值测试的数据

取值：按照边界值分析法 ， 一般选取**刚好等于、稍小于和稍大于**等价类边界值的数据作为测试数据 。

一般边界值分析法作为等价类划分法的补充与细化 。

**边界值分析法应当遵循的原则**：

- 按照输入值范围的边界 。

  例如：输入值的范围是$-1.0$至$1.0$，则设计用例：$-1.0,1.0,-1.001,1.001$。

- 按照输入 / 输出值个数的边界 。

  例如： 输入文件可有1-255个记录，则设计用例：文件的记录数为$0, 1, 255, 256$。

- 输出值域的边界 。

  例如：检索文献摘要，最多4篇，则设计用例：可检索篇数：$0,1,4,5$ 。

- 输入/输出有序集（如顺序文件 、 线性表）的边界 。

  应选择第一个元素和最后一个元素 。



### 实例

在上面实例2的基础上，使用边界值分析法设计测试用例。通常 ， 设计测试方案时会联合使用等价类划分和边界值分析两种技术 。以上一节的`NextDate`函数为例 ， 除了用等价类划分法设计出的测试方案外 ，还应该用边界值分析法补充以下测试方案 。

<img src="https://qihang-1306873228.cos.ap-chongqing.myqcloud.com/imgs/image-20230216214811414.png" alt="image-20230216214811414" style="zoom:67%;" />



## 3. 正交表法

详见PPT.C18.25-26
$$
测试用例数量 = 变量个数 \times (变量最大取值数目-1) + 1
$$
例如：某大学刚考完某门课程考试，想通过“性别”、“班级”、“成绩”三个查询条件对这门课程的成绩进行查询，查询条件包括：

- “性别” = “男、女”
- “班级” = “1班、2班”
- “成绩” = “及格、不及格”

一般来说是设计$2\times 2 \times 2 = 8$个测试用例。但如果使用正交数组法（正交表）法则只需要$3\times (2-1)+1 = 4$个测试用例。

